/* automatically generated by rust-bindgen */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const SYSTEM_CHARSET_MBMAXLEN: u32 = 3;
pub const FILENAME_CHARSET_MBMAXLEN: u32 = 5;
pub const NAME_CHAR_LEN: u32 = 64;
pub const PARTITION_EXPR_CHAR_LEN: u32 = 2048;
pub const USERNAME_CHAR_LENGTH: u32 = 32;
pub const USERNAME_CHAR_LENGTH_STR: &'static [u8; 3usize] = b"32\0";
pub const NAME_LEN: u32 = 192;
pub const USERNAME_LENGTH: u32 = 96;
pub const CONNECT_STRING_MAXLEN: u32 = 1024;
pub const MYSQL_AUTODETECT_CHARSET_NAME: &'static [u8; 5usize] = b"auto\0";
pub const SERVER_VERSION_LENGTH: u32 = 60;
pub const SQLSTATE_LENGTH: u32 = 5;
pub const TABLE_COMMENT_INLINE_MAXLEN: u32 = 180;
pub const TABLE_COMMENT_MAXLEN: u32 = 2048;
pub const COLUMN_COMMENT_MAXLEN: u32 = 1024;
pub const INDEX_COMMENT_MAXLEN: u32 = 1024;
pub const TABLE_PARTITION_COMMENT_MAXLEN: u32 = 1024;
pub const TABLESPACE_COMMENT_MAXLEN: u32 = 2048;
pub const MAX_PACKET_LENGTH: u32 = 16777215;
pub const LOCAL_HOST: &'static [u8; 10usize] = b"localhost\0";
pub const LOCAL_HOST_NAMEDPIPE: &'static [u8; 2usize] = b".\0";
pub const FRM_GCOL_HEADER_SIZE: u32 = 4;
pub const GENERATED_COLUMN_EXPRESSION_MAXLEN: u32 = 65531;
pub const SCRAMBLE_LENGTH: u32 = 20;
pub const AUTH_PLUGIN_DATA_PART_1_LENGTH: u32 = 8;
pub const SCRAMBLED_PASSWORD_CHAR_LENGTH: u32 = 41;
pub const NOT_NULL_FLAG: u32 = 1;
pub const PRI_KEY_FLAG: u32 = 2;
pub const UNIQUE_KEY_FLAG: u32 = 4;
pub const MULTIPLE_KEY_FLAG: u32 = 8;
pub const BLOB_FLAG: u32 = 16;
pub const UNSIGNED_FLAG: u32 = 32;
pub const ZEROFILL_FLAG: u32 = 64;
pub const BINARY_FLAG: u32 = 128;
pub const ENUM_FLAG: u32 = 256;
pub const AUTO_INCREMENT_FLAG: u32 = 512;
pub const TIMESTAMP_FLAG: u32 = 1024;
pub const SET_FLAG: u32 = 2048;
pub const NO_DEFAULT_VALUE_FLAG: u32 = 4096;
pub const ON_UPDATE_NOW_FLAG: u32 = 8192;
pub const NUM_FLAG: u32 = 32768;
pub const PART_KEY_FLAG: u32 = 16384;
pub const GROUP_FLAG: u32 = 32768;
pub const UNIQUE_FLAG: u32 = 65536;
pub const BINCMP_FLAG: u32 = 131072;
pub const GET_FIXED_FIELDS_FLAG: u32 = 262144;
pub const FIELD_IN_PART_FUNC_FLAG: u32 = 524288;
pub const FIELD_IN_ADD_INDEX: u32 = 1048576;
pub const FIELD_IS_RENAMED: u32 = 2097152;
pub const FIELD_FLAGS_STORAGE_MEDIA: u32 = 22;
pub const FIELD_FLAGS_STORAGE_MEDIA_MASK: u32 = 12582912;
pub const FIELD_FLAGS_COLUMN_FORMAT: u32 = 24;
pub const FIELD_FLAGS_COLUMN_FORMAT_MASK: u32 = 50331648;
pub const FIELD_IS_DROPPED: u32 = 67108864;
pub const EXPLICIT_NULL_FLAG: u32 = 134217728;
pub const FIELD_IS_MARKED: u32 = 268435456;
pub const NOT_SECONDARY_FLAG: u32 = 536870912;
pub const FIELD_IS_INVISIBLE: u32 = 1073741824;
pub const REFRESH_GRANT: u32 = 1;
pub const REFRESH_LOG: u32 = 2;
pub const REFRESH_TABLES: u32 = 4;
pub const REFRESH_HOSTS: u32 = 8;
pub const REFRESH_STATUS: u32 = 16;
pub const REFRESH_THREADS: u32 = 32;
pub const REFRESH_REPLICA: u32 = 64;
pub const REFRESH_SLAVE: u32 = 64;
pub const REFRESH_MASTER: u32 = 128;
pub const REFRESH_ERROR_LOG: u32 = 256;
pub const REFRESH_ENGINE_LOG: u32 = 512;
pub const REFRESH_BINARY_LOG: u32 = 1024;
pub const REFRESH_RELAY_LOG: u32 = 2048;
pub const REFRESH_GENERAL_LOG: u32 = 4096;
pub const REFRESH_SLOW_LOG: u32 = 8192;
pub const REFRESH_READ_LOCK: u32 = 16384;
pub const REFRESH_FAST: u32 = 32768;
pub const REFRESH_USER_RESOURCES: u32 = 524288;
pub const REFRESH_FOR_EXPORT: u32 = 1048576;
pub const REFRESH_OPTIMIZER_COSTS: u32 = 2097152;
pub const REFRESH_PERSIST: u32 = 4194304;
pub const CLIENT_LONG_PASSWORD: u32 = 1;
pub const CLIENT_FOUND_ROWS: u32 = 2;
pub const CLIENT_LONG_FLAG: u32 = 4;
pub const CLIENT_CONNECT_WITH_DB: u32 = 8;
pub const CLIENT_NO_SCHEMA: u32 = 16;
pub const CLIENT_COMPRESS: u32 = 32;
pub const CLIENT_ODBC: u32 = 64;
pub const CLIENT_LOCAL_FILES: u32 = 128;
pub const CLIENT_IGNORE_SPACE: u32 = 256;
pub const CLIENT_PROTOCOL_41: u32 = 512;
pub const CLIENT_INTERACTIVE: u32 = 1024;
pub const CLIENT_SSL: u32 = 2048;
pub const CLIENT_IGNORE_SIGPIPE: u32 = 4096;
pub const CLIENT_TRANSACTIONS: u32 = 8192;
pub const CLIENT_RESERVED: u32 = 16384;
pub const CLIENT_RESERVED2: u32 = 32768;
pub const CLIENT_MULTI_STATEMENTS: u32 = 65536;
pub const CLIENT_MULTI_RESULTS: u32 = 131072;
pub const CLIENT_PS_MULTI_RESULTS: u32 = 262144;
pub const CLIENT_PLUGIN_AUTH: u32 = 524288;
pub const CLIENT_CONNECT_ATTRS: u32 = 1048576;
pub const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA: u32 = 2097152;
pub const CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS: u32 = 4194304;
pub const CLIENT_SESSION_TRACK: u32 = 8388608;
pub const CLIENT_DEPRECATE_EOF: u32 = 16777216;
pub const CLIENT_OPTIONAL_RESULTSET_METADATA: u32 = 33554432;
pub const CLIENT_ZSTD_COMPRESSION_ALGORITHM: u32 = 67108864;
pub const CLIENT_QUERY_ATTRIBUTES: u32 = 134217728;
pub const CLIENT_CAPABILITY_EXTENSION: u32 = 536870912;
pub const CLIENT_SSL_VERIFY_SERVER_CERT: u32 = 1073741824;
pub const CLIENT_REMEMBER_OPTIONS: u32 = 2147483648;
pub const CAN_CLIENT_COMPRESS: u32 = 32;
pub const CLIENT_ALL_FLAGS: u32 = 3489660927;
pub const CLIENT_BASIC_FLAGS: u32 = 2348808159;
pub const MYSQL_ERRMSG_SIZE: u32 = 512;
pub const NET_READ_TIMEOUT: u32 = 30;
pub const NET_WRITE_TIMEOUT: u32 = 60;
pub const NET_WAIT_TIMEOUT: u32 = 28800;
pub const ONLY_KILL_QUERY: u32 = 1;
pub const MAX_TINYINT_WIDTH: u32 = 3;
pub const MAX_SMALLINT_WIDTH: u32 = 5;
pub const MAX_MEDIUMINT_WIDTH: u32 = 8;
pub const MAX_INT_WIDTH: u32 = 10;
pub const MAX_BIGINT_WIDTH: u32 = 20;
pub const MAX_CHAR_WIDTH: u32 = 255;
pub const MAX_BLOB_WIDTH: u32 = 16777216;
pub const CLIENT_MULTI_QUERIES: u32 = 65536;
pub const NET_HEADER_SIZE: u32 = 4;
pub const COMP_HEADER_SIZE: u32 = 3;
pub const MYSQL_STMT_HEADER: u32 = 4;
pub const MYSQL_LONG_DATA_HEADER: u32 = 6;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const MYSQL_CLIENT_reserved1: u32 = 0;
pub const MYSQL_CLIENT_reserved2: u32 = 1;
pub const MYSQL_CLIENT_AUTHENTICATION_PLUGIN: u32 = 2;
pub const MYSQL_CLIENT_TRACE_PLUGIN: u32 = 3;
pub const MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION: u32 = 257;
pub const MYSQL_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION: u32 = 256;
pub const MYSQL_CLIENT_MAX_PLUGINS: u32 = 4;
pub const MYSQL_CLIENT_PLUGIN_AUTHOR_ORACLE: &'static [u8; 19usize] = b"Oracle Corporation\0";
pub const MYSQL_USERNAME_LENGTH: u32 = 96;
pub const CR_AUTH_PLUGIN_ERROR: u32 = 3;
pub const CR_AUTH_HANDSHAKE: u32 = 2;
pub const CR_AUTH_USER_CREDENTIALS: u32 = 1;
pub const CR_ERROR: u32 = 0;
pub const CR_OK: i32 = -1;
pub const CR_OK_HANDSHAKE_COMPLETE: i32 = -2;
pub const PROXY_FLAG: u32 = 0;
pub const PROTOCOL_VERSION: u32 = 10;
pub const MYSQL_SERVER_VERSION: &'static [u8; 7usize] = b"8.0.23\0";
pub const MYSQL_BASE_VERSION: &'static [u8; 11usize] = b"mysqld-8.0\0";
pub const MYSQL_SERVER_SUFFIX_DEF: &'static [u8; 18usize] = b"-0ubuntu0.20.04.1\0";
pub const MYSQL_VERSION_ID: u32 = 80023;
pub const MYSQL_PORT: u32 = 3306;
pub const MYSQL_ADMIN_PORT: u32 = 33062;
pub const MYSQL_PORT_DEFAULT: u32 = 0;
pub const MYSQL_UNIX_ADDR: &'static [u8; 28usize] = b"/var/run/mysqld/mysqld.sock\0";
pub const MYSQL_CONFIG_NAME: &'static [u8; 3usize] = b"my\0";
pub const MYSQL_PERSIST_CONFIG_NAME: &'static [u8; 12usize] = b"mysqld-auto\0";
pub const MYSQL_COMPILATION_COMMENT: &'static [u8; 9usize] = b"(Ubuntu)\0";
pub const MYSQL_COMPILATION_COMMENT_SERVER: &'static [u8; 9usize] = b"(Ubuntu)\0";
pub const LIBMYSQL_VERSION: &'static [u8; 7usize] = b"8.0.23\0";
pub const LIBMYSQL_VERSION_ID: u32 = 80023;
pub const CR_MIN_ERROR: u32 = 2000;
pub const CR_MAX_ERROR: u32 = 2999;
pub const CLIENT_ERRMAP: u32 = 2;
pub const CR_ERROR_FIRST: u32 = 2000;
pub const CR_UNKNOWN_ERROR: u32 = 2000;
pub const CR_SOCKET_CREATE_ERROR: u32 = 2001;
pub const CR_CONNECTION_ERROR: u32 = 2002;
pub const CR_CONN_HOST_ERROR: u32 = 2003;
pub const CR_IPSOCK_ERROR: u32 = 2004;
pub const CR_UNKNOWN_HOST: u32 = 2005;
pub const CR_SERVER_GONE_ERROR: u32 = 2006;
pub const CR_VERSION_ERROR: u32 = 2007;
pub const CR_OUT_OF_MEMORY: u32 = 2008;
pub const CR_WRONG_HOST_INFO: u32 = 2009;
pub const CR_LOCALHOST_CONNECTION: u32 = 2010;
pub const CR_TCP_CONNECTION: u32 = 2011;
pub const CR_SERVER_HANDSHAKE_ERR: u32 = 2012;
pub const CR_SERVER_LOST: u32 = 2013;
pub const CR_COMMANDS_OUT_OF_SYNC: u32 = 2014;
pub const CR_NAMEDPIPE_CONNECTION: u32 = 2015;
pub const CR_NAMEDPIPEWAIT_ERROR: u32 = 2016;
pub const CR_NAMEDPIPEOPEN_ERROR: u32 = 2017;
pub const CR_NAMEDPIPESETSTATE_ERROR: u32 = 2018;
pub const CR_CANT_READ_CHARSET: u32 = 2019;
pub const CR_NET_PACKET_TOO_LARGE: u32 = 2020;
pub const CR_EMBEDDED_CONNECTION: u32 = 2021;
pub const CR_PROBE_SLAVE_STATUS: u32 = 2022;
pub const CR_PROBE_SLAVE_HOSTS: u32 = 2023;
pub const CR_PROBE_SLAVE_CONNECT: u32 = 2024;
pub const CR_PROBE_MASTER_CONNECT: u32 = 2025;
pub const CR_SSL_CONNECTION_ERROR: u32 = 2026;
pub const CR_MALFORMED_PACKET: u32 = 2027;
pub const CR_WRONG_LICENSE: u32 = 2028;
pub const CR_NULL_POINTER: u32 = 2029;
pub const CR_NO_PREPARE_STMT: u32 = 2030;
pub const CR_PARAMS_NOT_BOUND: u32 = 2031;
pub const CR_DATA_TRUNCATED: u32 = 2032;
pub const CR_NO_PARAMETERS_EXISTS: u32 = 2033;
pub const CR_INVALID_PARAMETER_NO: u32 = 2034;
pub const CR_INVALID_BUFFER_USE: u32 = 2035;
pub const CR_UNSUPPORTED_PARAM_TYPE: u32 = 2036;
pub const CR_SHARED_MEMORY_CONNECTION: u32 = 2037;
pub const CR_SHARED_MEMORY_CONNECT_REQUEST_ERROR: u32 = 2038;
pub const CR_SHARED_MEMORY_CONNECT_ANSWER_ERROR: u32 = 2039;
pub const CR_SHARED_MEMORY_CONNECT_FILE_MAP_ERROR: u32 = 2040;
pub const CR_SHARED_MEMORY_CONNECT_MAP_ERROR: u32 = 2041;
pub const CR_SHARED_MEMORY_FILE_MAP_ERROR: u32 = 2042;
pub const CR_SHARED_MEMORY_MAP_ERROR: u32 = 2043;
pub const CR_SHARED_MEMORY_EVENT_ERROR: u32 = 2044;
pub const CR_SHARED_MEMORY_CONNECT_ABANDONED_ERROR: u32 = 2045;
pub const CR_SHARED_MEMORY_CONNECT_SET_ERROR: u32 = 2046;
pub const CR_CONN_UNKNOW_PROTOCOL: u32 = 2047;
pub const CR_INVALID_CONN_HANDLE: u32 = 2048;
pub const CR_UNUSED_1: u32 = 2049;
pub const CR_FETCH_CANCELED: u32 = 2050;
pub const CR_NO_DATA: u32 = 2051;
pub const CR_NO_STMT_METADATA: u32 = 2052;
pub const CR_NO_RESULT_SET: u32 = 2053;
pub const CR_NOT_IMPLEMENTED: u32 = 2054;
pub const CR_SERVER_LOST_EXTENDED: u32 = 2055;
pub const CR_STMT_CLOSED: u32 = 2056;
pub const CR_NEW_STMT_METADATA: u32 = 2057;
pub const CR_ALREADY_CONNECTED: u32 = 2058;
pub const CR_AUTH_PLUGIN_CANNOT_LOAD: u32 = 2059;
pub const CR_DUPLICATE_CONNECTION_ATTR: u32 = 2060;
pub const CR_AUTH_PLUGIN_ERR: u32 = 2061;
pub const CR_INSECURE_API_ERR: u32 = 2062;
pub const CR_FILE_NAME_TOO_LONG: u32 = 2063;
pub const CR_SSL_FIPS_MODE_ERR: u32 = 2064;
pub const CR_DEPRECATED_COMPRESSION_NOT_SUPPORTED: u32 = 2065;
pub const CR_COMPRESSION_WRONGLY_CONFIGURED: u32 = 2066;
pub const CR_KERBEROS_USER_NOT_FOUND: u32 = 2067;
pub const CR_LOAD_DATA_LOCAL_INFILE_REJECTED: u32 = 2068;
pub const CR_LOAD_DATA_LOCAL_INFILE_REALPATH_FAIL: u32 = 2069;
pub const CR_DNS_SRV_LOOKUP_FAILED: u32 = 2070;
pub const CR_ERROR_LAST: u32 = 2070;
pub const CLIENT_NET_RETRY_COUNT: u32 = 1;
pub const CLIENT_NET_READ_TIMEOUT: u32 = 31536000;
pub const CLIENT_NET_WRITE_TIMEOUT: u32 = 31536000;
pub const MYSQL_RPL_GTID: u32 = 65536;
pub const MYSQL_RPL_SKIP_HEARTBEAT: u32 = 131072;
pub const LOCAL_INFILE_ERROR_LEN: u32 = 512;
pub const MYSQL_NO_DATA: u32 = 100;
pub const MYSQL_DATA_TRUNCATED: u32 = 101;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__sigset_t), "::", stringify!(__val))
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(timeval), "::", stringify!(tv_sec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(timeval), "::", stringify!(tv_usec))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_sec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(timespec), "::", stringify!(tv_nsec))
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(fd_set), "::", stringify!(__fds_bits))
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type my_ulonglong = u64;
pub type my_socket = ::std::os::raw::c_int;
pub const enum_field_types_MYSQL_TYPE_DECIMAL: enum_field_types = 0;
pub const enum_field_types_MYSQL_TYPE_TINY: enum_field_types = 1;
pub const enum_field_types_MYSQL_TYPE_SHORT: enum_field_types = 2;
pub const enum_field_types_MYSQL_TYPE_LONG: enum_field_types = 3;
pub const enum_field_types_MYSQL_TYPE_FLOAT: enum_field_types = 4;
pub const enum_field_types_MYSQL_TYPE_DOUBLE: enum_field_types = 5;
pub const enum_field_types_MYSQL_TYPE_NULL: enum_field_types = 6;
pub const enum_field_types_MYSQL_TYPE_TIMESTAMP: enum_field_types = 7;
pub const enum_field_types_MYSQL_TYPE_LONGLONG: enum_field_types = 8;
pub const enum_field_types_MYSQL_TYPE_INT24: enum_field_types = 9;
pub const enum_field_types_MYSQL_TYPE_DATE: enum_field_types = 10;
pub const enum_field_types_MYSQL_TYPE_TIME: enum_field_types = 11;
pub const enum_field_types_MYSQL_TYPE_DATETIME: enum_field_types = 12;
pub const enum_field_types_MYSQL_TYPE_YEAR: enum_field_types = 13;
#[doc = "< Internal to MySQL. Not used in protocol"]
pub const enum_field_types_MYSQL_TYPE_NEWDATE: enum_field_types = 14;
pub const enum_field_types_MYSQL_TYPE_VARCHAR: enum_field_types = 15;
pub const enum_field_types_MYSQL_TYPE_BIT: enum_field_types = 16;
pub const enum_field_types_MYSQL_TYPE_TIMESTAMP2: enum_field_types = 17;
#[doc = "< Internal to MySQL. Not used in protocol"]
pub const enum_field_types_MYSQL_TYPE_DATETIME2: enum_field_types = 18;
#[doc = "< Internal to MySQL. Not used in protocol"]
pub const enum_field_types_MYSQL_TYPE_TIME2: enum_field_types = 19;
#[doc = "< Used for replication only"]
pub const enum_field_types_MYSQL_TYPE_TYPED_ARRAY: enum_field_types = 20;
pub const enum_field_types_MYSQL_TYPE_INVALID: enum_field_types = 243;
#[doc = "< Currently just a placeholder"]
pub const enum_field_types_MYSQL_TYPE_BOOL: enum_field_types = 244;
pub const enum_field_types_MYSQL_TYPE_JSON: enum_field_types = 245;
pub const enum_field_types_MYSQL_TYPE_NEWDECIMAL: enum_field_types = 246;
pub const enum_field_types_MYSQL_TYPE_ENUM: enum_field_types = 247;
pub const enum_field_types_MYSQL_TYPE_SET: enum_field_types = 248;
pub const enum_field_types_MYSQL_TYPE_TINY_BLOB: enum_field_types = 249;
pub const enum_field_types_MYSQL_TYPE_MEDIUM_BLOB: enum_field_types = 250;
pub const enum_field_types_MYSQL_TYPE_LONG_BLOB: enum_field_types = 251;
pub const enum_field_types_MYSQL_TYPE_BLOB: enum_field_types = 252;
pub const enum_field_types_MYSQL_TYPE_VAR_STRING: enum_field_types = 253;
pub const enum_field_types_MYSQL_TYPE_STRING: enum_field_types = 254;
pub const enum_field_types_MYSQL_TYPE_GEOMETRY: enum_field_types = 255;
#[doc = "Column types for MySQL"]
pub type enum_field_types = u32;
#[doc = "@file include/my_list.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST {
    pub prev: *mut LIST,
    pub next: *mut LIST,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_LIST() {
    assert_eq!(
        ::std::mem::size_of::<LIST>(),
        24usize,
        concat!("Size of: ", stringify!(LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(LIST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIST>())).prev as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(LIST), "::", stringify!(prev))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIST>())).next as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(LIST), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIST>())).data as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(LIST), "::", stringify!(data))
    );
}
pub type list_walk_action = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn list_add(root: *mut LIST, element: *mut LIST) -> *mut LIST;
}
extern "C" {
    pub fn list_delete(root: *mut LIST, element: *mut LIST) -> *mut LIST;
}
extern "C" {
    pub fn list_cons(data: *mut ::std::os::raw::c_void, root: *mut LIST) -> *mut LIST;
}
extern "C" {
    pub fn list_reverse(root: *mut LIST) -> *mut LIST;
}
extern "C" {
    pub fn list_free(root: *mut LIST, free_data: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn list_length(arg1: *mut LIST) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn list_walk(
        arg1: *mut LIST,
        action: list_walk_action,
        argument: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[doc = "Currently refused by the server. See ::dispatch_command."]
#[doc = "Also used internally to mark the start of a session."]
pub const enum_server_command_COM_SLEEP: enum_server_command = 0;
#[doc = "< See @ref page_protocol_com_quit"]
pub const enum_server_command_COM_QUIT: enum_server_command = 1;
#[doc = "< See @ref page_protocol_com_init_db"]
pub const enum_server_command_COM_INIT_DB: enum_server_command = 2;
#[doc = "< See @ref page_protocol_com_query"]
pub const enum_server_command_COM_QUERY: enum_server_command = 3;
#[doc = "< Deprecated. See @ref page_protocol_com_field_list"]
pub const enum_server_command_COM_FIELD_LIST: enum_server_command = 4;
#[doc = "< Currently refused by the server. See ::dispatch_command"]
pub const enum_server_command_COM_CREATE_DB: enum_server_command = 5;
#[doc = "< Currently refused by the server. See ::dispatch_command"]
pub const enum_server_command_COM_DROP_DB: enum_server_command = 6;
#[doc = "< Deprecated. See @ref page_protocol_com_refresh"]
pub const enum_server_command_COM_REFRESH: enum_server_command = 7;
#[doc = "< Deprecated, used to be COM_SHUTDOWN"]
pub const enum_server_command_COM_DEPRECATED_1: enum_server_command = 8;
#[doc = "< See @ref page_protocol_com_statistics"]
pub const enum_server_command_COM_STATISTICS: enum_server_command = 9;
#[doc = "< Deprecated. See @ref page_protocol_com_process_info"]
pub const enum_server_command_COM_PROCESS_INFO: enum_server_command = 10;
#[doc = "< Currently refused by the server."]
pub const enum_server_command_COM_CONNECT: enum_server_command = 11;
#[doc = "< Deprecated. See @ref page_protocol_com_process_kill"]
pub const enum_server_command_COM_PROCESS_KILL: enum_server_command = 12;
#[doc = "< See @ref page_protocol_com_debug"]
pub const enum_server_command_COM_DEBUG: enum_server_command = 13;
#[doc = "< See @ref page_protocol_com_ping"]
pub const enum_server_command_COM_PING: enum_server_command = 14;
#[doc = "< Currently refused by the server."]
pub const enum_server_command_COM_TIME: enum_server_command = 15;
#[doc = "< Functionality removed."]
pub const enum_server_command_COM_DELAYED_INSERT: enum_server_command = 16;
#[doc = "< See @ref page_protocol_com_change_user"]
pub const enum_server_command_COM_CHANGE_USER: enum_server_command = 17;
#[doc = "< See @ref page_protocol_com_binlog_dump"]
pub const enum_server_command_COM_BINLOG_DUMP: enum_server_command = 18;
pub const enum_server_command_COM_TABLE_DUMP: enum_server_command = 19;
pub const enum_server_command_COM_CONNECT_OUT: enum_server_command = 20;
pub const enum_server_command_COM_REGISTER_SLAVE: enum_server_command = 21;
#[doc = "< See @ref page_protocol_com_stmt_prepare"]
pub const enum_server_command_COM_STMT_PREPARE: enum_server_command = 22;
#[doc = "< See @ref page_protocol_com_stmt_execute"]
pub const enum_server_command_COM_STMT_EXECUTE: enum_server_command = 23;
#[doc = " See  @ref page_protocol_com_stmt_send_long_data"]
pub const enum_server_command_COM_STMT_SEND_LONG_DATA: enum_server_command = 24;
#[doc = "< See @ref page_protocol_com_stmt_close"]
pub const enum_server_command_COM_STMT_CLOSE: enum_server_command = 25;
#[doc = "< See @ref page_protocol_com_stmt_reset"]
pub const enum_server_command_COM_STMT_RESET: enum_server_command = 26;
#[doc = "< See @ref page_protocol_com_set_option"]
pub const enum_server_command_COM_SET_OPTION: enum_server_command = 27;
#[doc = "< See @ref page_protocol_com_stmt_fetch"]
pub const enum_server_command_COM_STMT_FETCH: enum_server_command = 28;
#[doc = "Currently refused by the server. See ::dispatch_command."]
#[doc = "Also used internally to mark the session as a \"daemon\","]
#[doc = "i.e. non-client THD. Currently the scheduler and the GTID"]
#[doc = "code does use this state."]
#[doc = "These threads won't be killed by `KILL`"]
#[doc = ""]
#[doc = "@sa Event_scheduler::start, ::init_thd, ::kill_one_thread,"]
#[doc = "::Find_thd_with_id"]
pub const enum_server_command_COM_DAEMON: enum_server_command = 29;
#[doc = "Currently refused by the server. See ::dispatch_command."]
#[doc = "Also used internally to mark the session as a \"daemon\","]
#[doc = "i.e. non-client THD. Currently the scheduler and the GTID"]
#[doc = "code does use this state."]
#[doc = "These threads won't be killed by `KILL`"]
#[doc = ""]
#[doc = "@sa Event_scheduler::start, ::init_thd, ::kill_one_thread,"]
#[doc = "::Find_thd_with_id"]
pub const enum_server_command_COM_BINLOG_DUMP_GTID: enum_server_command = 30;
#[doc = "< See @ref page_protocol_com_reset_connection"]
pub const enum_server_command_COM_RESET_CONNECTION: enum_server_command = 31;
pub const enum_server_command_COM_CLONE: enum_server_command = 32;
#[doc = "< Not a real command. Refused."]
pub const enum_server_command_COM_END: enum_server_command = 33;
#[doc = "@enum  enum_server_command"]
#[doc = ""]
#[doc = "@brief A list of all MySQL protocol commands."]
#[doc = ""]
#[doc = "These are the top level commands the server can receive"]
#[doc = "while it listens for a new command in ::dispatch_command"]
#[doc = ""]
#[doc = "@par Warning"]
#[doc = "Add new commands to the end of this list, otherwise old"]
#[doc = "servers won't be able to handle them as 'unsupported'."]
pub type enum_server_command = u32;
pub const enum_compression_algorithm_MYSQL_UNCOMPRESSED: enum_compression_algorithm = 1;
pub const enum_compression_algorithm_MYSQL_ZLIB: enum_compression_algorithm = 2;
pub const enum_compression_algorithm_MYSQL_ZSTD: enum_compression_algorithm = 3;
pub const enum_compression_algorithm_MYSQL_INVALID: enum_compression_algorithm = 4;
pub type enum_compression_algorithm = u32;
#[doc = "Compress context information. relating to zlib compression."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mysql_zlib_compress_context {
    #[doc = "Compression level to use in zlib compression."]
    pub compression_level: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mysql_zlib_compress_context() {
    assert_eq!(
        ::std::mem::size_of::<mysql_zlib_compress_context>(),
        4usize,
        concat!("Size of: ", stringify!(mysql_zlib_compress_context))
    );
    assert_eq!(
        ::std::mem::align_of::<mysql_zlib_compress_context>(),
        4usize,
        concat!("Alignment of ", stringify!(mysql_zlib_compress_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mysql_zlib_compress_context>())).compression_level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mysql_zlib_compress_context),
            "::",
            stringify!(compression_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_CCtx_s {
    _unused: [u8; 0],
}
pub type ZSTD_CCtx = ZSTD_CCtx_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZSTD_DCtx_s {
    _unused: [u8; 0],
}
pub type ZSTD_DCtx = ZSTD_DCtx_s;
#[doc = "Compress context information relating to zstd compression."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mysql_zstd_compress_context {
    #[doc = "Pointer to compressor context."]
    pub cctx: *mut ZSTD_CCtx,
    #[doc = "Pointer to decompressor context."]
    pub dctx: *mut ZSTD_DCtx,
    #[doc = "Compression level to use in zstd compression."]
    pub compression_level: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mysql_zstd_compress_context() {
    assert_eq!(
        ::std::mem::size_of::<mysql_zstd_compress_context>(),
        24usize,
        concat!("Size of: ", stringify!(mysql_zstd_compress_context))
    );
    assert_eq!(
        ::std::mem::align_of::<mysql_zstd_compress_context>(),
        8usize,
        concat!("Alignment of ", stringify!(mysql_zstd_compress_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mysql_zstd_compress_context>())).cctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mysql_zstd_compress_context),
            "::",
            stringify!(cctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mysql_zstd_compress_context>())).dctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mysql_zstd_compress_context),
            "::",
            stringify!(dctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mysql_zstd_compress_context>())).compression_level as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mysql_zstd_compress_context),
            "::",
            stringify!(compression_level)
        )
    );
}
#[doc = "Compression context information."]
#[doc = "It encapsulate the context information based on compression method and"]
#[doc = "presents a generic struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mysql_compress_context {
    #[doc = "< Compression algorithm name."]
    pub algorithm: enum_compression_algorithm,
    pub u: mysql_compress_context__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mysql_compress_context__bindgen_ty_1 {
    #[doc = "< Context information of zlib."]
    pub zlib_ctx: mysql_zlib_compress_context,
    #[doc = "< Context information of zstd."]
    pub zstd_ctx: mysql_zstd_compress_context,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_mysql_compress_context__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mysql_compress_context__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(mysql_compress_context__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mysql_compress_context__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mysql_compress_context__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mysql_compress_context__bindgen_ty_1>())).zlib_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mysql_compress_context__bindgen_ty_1),
            "::",
            stringify!(zlib_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mysql_compress_context__bindgen_ty_1>())).zstd_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mysql_compress_context__bindgen_ty_1),
            "::",
            stringify!(zstd_ctx)
        )
    );
}
#[test]
fn bindgen_test_layout_mysql_compress_context() {
    assert_eq!(
        ::std::mem::size_of::<mysql_compress_context>(),
        32usize,
        concat!("Size of: ", stringify!(mysql_compress_context))
    );
    assert_eq!(
        ::std::mem::align_of::<mysql_compress_context>(),
        8usize,
        concat!("Alignment of ", stringify!(mysql_compress_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mysql_compress_context>())).algorithm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mysql_compress_context),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mysql_compress_context>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mysql_compress_context),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    #[doc = "Get default compression level corresponding to a given compression method."]
    #[doc = ""]
    #[doc = "@param algorithm Compression Method. Possible values are zlib or zstd."]
    #[doc = ""]
    #[doc = "@return an unsigned int representing default compression level."]
    #[doc = "6 is the default compression level for zlib and 3 is the"]
    #[doc = "default compression level for zstd."]
    pub fn mysql_default_compression_level(algorithm: enum_compression_algorithm) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "Initialize a compress context object to be associated with a NET object."]
    #[doc = ""]
    #[doc = "@param cmp_ctx Pointer to compression context."]
    #[doc = "@param algorithm Compression algorithm."]
    #[doc = "@param compression_level Compression level corresponding to the compression"]
    #[doc = "algorithm."]
    pub fn mysql_compress_context_init(
        cmp_ctx: *mut mysql_compress_context,
        algorithm: enum_compression_algorithm,
        compression_level: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "Deinitialize the compression context allocated."]
    #[doc = ""]
    #[doc = "@param mysql_compress_ctx Pointer to Compression context."]
    pub fn mysql_compress_context_deinit(mysql_compress_ctx: *mut mysql_compress_context);
}
#[doc = "Is raised when a multi-statement transaction"]
#[doc = "has been started, either explicitly, by means"]
#[doc = "of BEGIN or COMMIT AND CHAIN, or"]
#[doc = "implicitly, by the first transactional"]
#[doc = "statement, when autocommit=off."]
pub const SERVER_STATUS_flags_enum_SERVER_STATUS_IN_TRANS: SERVER_STATUS_flags_enum = 1;
#[doc = "< Server in auto_commit mode"]
pub const SERVER_STATUS_flags_enum_SERVER_STATUS_AUTOCOMMIT: SERVER_STATUS_flags_enum = 2;
#[doc = "< Multi query - next query exists"]
pub const SERVER_STATUS_flags_enum_SERVER_MORE_RESULTS_EXISTS: SERVER_STATUS_flags_enum = 8;
pub const SERVER_STATUS_flags_enum_SERVER_QUERY_NO_GOOD_INDEX_USED: SERVER_STATUS_flags_enum = 16;
pub const SERVER_STATUS_flags_enum_SERVER_QUERY_NO_INDEX_USED: SERVER_STATUS_flags_enum = 32;
#[doc = "The server was able to fulfill the clients request and opened a"]
#[doc = "read-only non-scrollable cursor for a query. This flag comes"]
#[doc = "in reply to COM_STMT_EXECUTE and COM_STMT_FETCH commands."]
#[doc = "Used by Binary Protocol Resultset to signal that COM_STMT_FETCH"]
#[doc = "must be used to fetch the row-data."]
#[doc = "@todo Refify \"Binary Protocol Resultset\" and \"COM_STMT_FETCH\"."]
pub const SERVER_STATUS_flags_enum_SERVER_STATUS_CURSOR_EXISTS: SERVER_STATUS_flags_enum = 64;
#[doc = "This flag is sent when a read-only cursor is exhausted, in reply to"]
#[doc = "COM_STMT_FETCH command."]
pub const SERVER_STATUS_flags_enum_SERVER_STATUS_LAST_ROW_SENT: SERVER_STATUS_flags_enum = 128;
#[doc = "< A database was dropped"]
pub const SERVER_STATUS_flags_enum_SERVER_STATUS_DB_DROPPED: SERVER_STATUS_flags_enum = 256;
pub const SERVER_STATUS_flags_enum_SERVER_STATUS_NO_BACKSLASH_ESCAPES: SERVER_STATUS_flags_enum = 512;
#[doc = "Sent to the client if after a prepared statement reprepare"]
#[doc = "we discovered that the new statement returns a different"]
#[doc = "number of result set columns."]
pub const SERVER_STATUS_flags_enum_SERVER_STATUS_METADATA_CHANGED: SERVER_STATUS_flags_enum = 1024;
#[doc = "Sent to the client if after a prepared statement reprepare"]
#[doc = "we discovered that the new statement returns a different"]
#[doc = "number of result set columns."]
pub const SERVER_STATUS_flags_enum_SERVER_QUERY_WAS_SLOW: SERVER_STATUS_flags_enum = 2048;
#[doc = "To mark ResultSet containing output parameter values."]
pub const SERVER_STATUS_flags_enum_SERVER_PS_OUT_PARAMS: SERVER_STATUS_flags_enum = 4096;
#[doc = "Set at the same time as SERVER_STATUS_IN_TRANS if the started"]
#[doc = "multi-statement transaction is a read-only transaction. Cleared"]
#[doc = "when the transaction commits or aborts. Since this flag is sent"]
#[doc = "to clients in OK and EOF packets, the flag indicates the"]
#[doc = "transaction status at the end of command execution."]
pub const SERVER_STATUS_flags_enum_SERVER_STATUS_IN_TRANS_READONLY: SERVER_STATUS_flags_enum = 8192;
#[doc = "This status flag, when on, implies that one of the state information has"]
#[doc = "changed on the server because of the execution of the last statement."]
pub const SERVER_STATUS_flags_enum_SERVER_SESSION_STATE_CHANGED: SERVER_STATUS_flags_enum = 16384;
#[doc = " The status flags are a bit-field"]
pub type SERVER_STATUS_flags_enum = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NET {
    pub vio: *mut Vio,
    pub buff: *mut ::std::os::raw::c_uchar,
    pub buff_end: *mut ::std::os::raw::c_uchar,
    pub write_pos: *mut ::std::os::raw::c_uchar,
    pub read_pos: *mut ::std::os::raw::c_uchar,
    pub fd: my_socket,
    #[doc = "Set if we are doing several queries in one"]
    #[doc = "command ( as in LOAD TABLE ... FROM MASTER ),"]
    #[doc = "and do not want to confuse the client with OK at the wrong time"]
    pub remain_in_buf: ::std::os::raw::c_ulong,
    #[doc = "Set if we are doing several queries in one"]
    #[doc = "command ( as in LOAD TABLE ... FROM MASTER ),"]
    #[doc = "and do not want to confuse the client with OK at the wrong time"]
    pub length: ::std::os::raw::c_ulong,
    #[doc = "Set if we are doing several queries in one"]
    #[doc = "command ( as in LOAD TABLE ... FROM MASTER ),"]
    #[doc = "and do not want to confuse the client with OK at the wrong time"]
    pub buf_length: ::std::os::raw::c_ulong,
    #[doc = "Set if we are doing several queries in one"]
    #[doc = "command ( as in LOAD TABLE ... FROM MASTER ),"]
    #[doc = "and do not want to confuse the client with OK at the wrong time"]
    pub where_b: ::std::os::raw::c_ulong,
    pub max_packet: ::std::os::raw::c_ulong,
    pub max_packet_size: ::std::os::raw::c_ulong,
    pub pkt_nr: ::std::os::raw::c_uint,
    pub compress_pkt_nr: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub retry_count: ::std::os::raw::c_uint,
    pub fcntl: ::std::os::raw::c_int,
    pub return_status: *mut ::std::os::raw::c_uint,
    pub reading_or_writing: ::std::os::raw::c_uchar,
    pub save_char: ::std::os::raw::c_uchar,
    pub compress: bool,
    pub last_errno: ::std::os::raw::c_uint,
    pub error: ::std::os::raw::c_uchar,
    #[doc = " Client library error message buffer. Actually belongs to struct MYSQL."]
    pub last_error: [::std::os::raw::c_char; 512usize],
    #[doc = " Client library sqlstate buffer. Set along with the error message."]
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    #[doc = "Extension pointer, for the caller private use."]
    #[doc = "Any program linking with the networking library can use this pointer,"]
    #[doc = "which is handy when private connection specific data needs to be"]
    #[doc = "maintained."]
    #[doc = "The mysqld server process uses this pointer internally,"]
    #[doc = "to maintain the server internal instrumentation for the connection."]
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_NET() {
    assert_eq!(
        ::std::mem::size_of::<NET>(),
        664usize,
        concat!("Size of: ", stringify!(NET))
    );
    assert_eq!(
        ::std::mem::align_of::<NET>(),
        8usize,
        concat!("Alignment of ", stringify!(NET))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).vio as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(vio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).buff as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(buff))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).buff_end as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(buff_end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).write_pos as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(write_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).read_pos as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(read_pos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).fd as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(fd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).remain_in_buf as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(remain_in_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).length as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).buf_length as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(buf_length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).where_b as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(where_b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).max_packet as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(max_packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).max_packet_size as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(max_packet_size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).pkt_nr as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(pkt_nr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).compress_pkt_nr as *const _ as usize },
        100usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(compress_pkt_nr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).write_timeout as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(write_timeout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).read_timeout as *const _ as usize },
        108usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(read_timeout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).retry_count as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(retry_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).fcntl as *const _ as usize },
        116usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(fcntl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).return_status as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(return_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).reading_or_writing as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NET),
            "::",
            stringify!(reading_or_writing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).save_char as *const _ as usize },
        129usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(save_char))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).compress as *const _ as usize },
        130usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(compress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).last_errno as *const _ as usize },
        132usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(last_errno))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).error as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).last_error as *const _ as usize },
        137usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(last_error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).sqlstate as *const _ as usize },
        649usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(sqlstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NET>())).extension as *const _ as usize },
        656usize,
        concat!("Offset of field: ", stringify!(NET), "::", stringify!(extension))
    );
}
pub const mysql_enum_shutdown_level_SHUTDOWN_DEFAULT: mysql_enum_shutdown_level = 0;
#[doc = " Wait for existing connections to finish"]
pub const mysql_enum_shutdown_level_SHUTDOWN_WAIT_CONNECTIONS: mysql_enum_shutdown_level = 1;
#[doc = " Wait for existing transactons to finish"]
pub const mysql_enum_shutdown_level_SHUTDOWN_WAIT_TRANSACTIONS: mysql_enum_shutdown_level = 2;
#[doc = " Wait for existing updates to finish (=> no partial MyISAM update)"]
pub const mysql_enum_shutdown_level_SHUTDOWN_WAIT_UPDATES: mysql_enum_shutdown_level = 8;
#[doc = " Flush InnoDB buffers and other storage engines' buffers"]
pub const mysql_enum_shutdown_level_SHUTDOWN_WAIT_ALL_BUFFERS: mysql_enum_shutdown_level = 16;
#[doc = " Don't flush InnoDB buffers, flush other storage engines' buffers"]
pub const mysql_enum_shutdown_level_SHUTDOWN_WAIT_CRITICAL_BUFFERS: mysql_enum_shutdown_level = 17;
#[doc = " Query level of the KILL command"]
pub const mysql_enum_shutdown_level_KILL_QUERY: mysql_enum_shutdown_level = 254;
#[doc = " Connection level of the KILL command"]
pub const mysql_enum_shutdown_level_KILL_CONNECTION: mysql_enum_shutdown_level = 255;
#[doc = "We want levels to be in growing order of hardness (because we use number"]
#[doc = "comparisons)."]
#[doc = ""]
#[doc = "@note ::SHUTDOWN_DEFAULT does not respect the growing property, but it's ok."]
pub type mysql_enum_shutdown_level = u32;
#[doc = " No metadata will be sent."]
pub const enum_resultset_metadata_RESULTSET_METADATA_NONE: enum_resultset_metadata = 0;
#[doc = " The server will send all metadata."]
pub const enum_resultset_metadata_RESULTSET_METADATA_FULL: enum_resultset_metadata = 1;
#[doc = " @}"]
pub type enum_resultset_metadata = u32;
pub const enum_cursor_type_CURSOR_TYPE_NO_CURSOR: enum_cursor_type = 0;
pub const enum_cursor_type_CURSOR_TYPE_READ_ONLY: enum_cursor_type = 1;
pub const enum_cursor_type_CURSOR_TYPE_FOR_UPDATE: enum_cursor_type = 2;
pub const enum_cursor_type_CURSOR_TYPE_SCROLLABLE: enum_cursor_type = 4;
pub type enum_cursor_type = u32;
pub const enum_mysql_set_option_MYSQL_OPTION_MULTI_STATEMENTS_ON: enum_mysql_set_option = 0;
pub const enum_mysql_set_option_MYSQL_OPTION_MULTI_STATEMENTS_OFF: enum_mysql_set_option = 1;
#[doc = " options for ::mysql_options()"]
pub type enum_mysql_set_option = u32;
#[doc = "< Session system variables"]
pub const enum_session_state_type_SESSION_TRACK_SYSTEM_VARIABLES: enum_session_state_type = 0;
#[doc = "< Current schema"]
pub const enum_session_state_type_SESSION_TRACK_SCHEMA: enum_session_state_type = 1;
#[doc = "< track session state changes"]
pub const enum_session_state_type_SESSION_TRACK_STATE_CHANGE: enum_session_state_type = 2;
#[doc = "< See also: session_track_gtids"]
pub const enum_session_state_type_SESSION_TRACK_GTIDS: enum_session_state_type = 3;
#[doc = "< Transaction chistics"]
pub const enum_session_state_type_SESSION_TRACK_TRANSACTION_CHARACTERISTICS: enum_session_state_type = 4;
#[doc = "< Transaction state"]
pub const enum_session_state_type_SESSION_TRACK_TRANSACTION_STATE: enum_session_state_type = 5;
#[doc = "Type of state change information that the server can include in the Ok"]
#[doc = "packet."]
#[doc = ""]
#[doc = "@note"]
#[doc = "- session_state_type shouldn't go past 255 (i.e. 1-byte boundary)."]
#[doc = "- Modify the definition of ::SESSION_TRACK_END when a new member is added."]
pub type enum_session_state_type = u32;
extern "C" {
    pub fn my_net_init(net: *mut NET, vio: *mut Vio) -> bool;
}
extern "C" {
    pub fn my_net_local_init(net: *mut NET);
}
extern "C" {
    pub fn net_end(net: *mut NET);
}
extern "C" {
    pub fn net_clear(net: *mut NET, check_buffer: bool);
}
extern "C" {
    pub fn net_claim_memory_ownership(net: *mut NET, claim: bool);
}
extern "C" {
    pub fn net_realloc(net: *mut NET, length: size_t) -> bool;
}
extern "C" {
    pub fn net_flush(net: *mut NET) -> bool;
}
extern "C" {
    pub fn my_net_write(net: *mut NET, packet: *const ::std::os::raw::c_uchar, len: size_t) -> bool;
}
extern "C" {
    pub fn net_write_command(
        net: *mut NET,
        command: ::std::os::raw::c_uchar,
        header: *const ::std::os::raw::c_uchar,
        head_len: size_t,
        packet: *const ::std::os::raw::c_uchar,
        len: size_t,
    ) -> bool;
}
extern "C" {
    pub fn net_write_packet(net: *mut NET, packet: *const ::std::os::raw::c_uchar, length: size_t) -> bool;
}
extern "C" {
    pub fn my_net_read(net: *mut NET) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn my_net_set_write_timeout(net: *mut NET, timeout: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn my_net_set_read_timeout(net: *mut NET, timeout: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn my_net_set_retry_count(net: *mut NET, retry_count: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_struct {
    pub seed1: ::std::os::raw::c_ulong,
    pub seed2: ::std::os::raw::c_ulong,
    pub max_value: ::std::os::raw::c_ulong,
    pub max_value_dbl: f64,
}
#[test]
fn bindgen_test_layout_rand_struct() {
    assert_eq!(
        ::std::mem::size_of::<rand_struct>(),
        32usize,
        concat!("Size of: ", stringify!(rand_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rand_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rand_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_struct>())).seed1 as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(rand_struct), "::", stringify!(seed1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_struct>())).seed2 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(rand_struct), "::", stringify!(seed2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_struct>())).max_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_struct),
            "::",
            stringify!(max_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_struct>())).max_value_dbl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_struct),
            "::",
            stringify!(max_value_dbl)
        )
    );
}
pub const Item_result_INVALID_RESULT: Item_result = -1;
pub const Item_result_STRING_RESULT: Item_result = 0;
pub const Item_result_REAL_RESULT: Item_result = 1;
pub const Item_result_INT_RESULT: Item_result = 2;
pub const Item_result_ROW_RESULT: Item_result = 3;
pub const Item_result_DECIMAL_RESULT: Item_result = 4;
pub type Item_result = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDF_ARGS {
    pub arg_count: ::std::os::raw::c_uint,
    pub arg_type: *mut Item_result,
    pub args: *mut *mut ::std::os::raw::c_char,
    pub lengths: *mut ::std::os::raw::c_ulong,
    pub maybe_null: *mut ::std::os::raw::c_char,
    pub attributes: *mut *mut ::std::os::raw::c_char,
    pub attribute_lengths: *mut ::std::os::raw::c_ulong,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_UDF_ARGS() {
    assert_eq!(
        ::std::mem::size_of::<UDF_ARGS>(),
        64usize,
        concat!("Size of: ", stringify!(UDF_ARGS))
    );
    assert_eq!(
        ::std::mem::align_of::<UDF_ARGS>(),
        8usize,
        concat!("Alignment of ", stringify!(UDF_ARGS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_ARGS>())).arg_count as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(UDF_ARGS), "::", stringify!(arg_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_ARGS>())).arg_type as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(UDF_ARGS), "::", stringify!(arg_type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_ARGS>())).args as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(UDF_ARGS), "::", stringify!(args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_ARGS>())).lengths as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(UDF_ARGS), "::", stringify!(lengths))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_ARGS>())).maybe_null as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(UDF_ARGS), "::", stringify!(maybe_null))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_ARGS>())).attributes as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(UDF_ARGS), "::", stringify!(attributes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_ARGS>())).attribute_lengths as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UDF_ARGS),
            "::",
            stringify!(attribute_lengths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_ARGS>())).extension as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(UDF_ARGS), "::", stringify!(extension))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDF_INIT {
    pub maybe_null: bool,
    pub decimals: ::std::os::raw::c_uint,
    pub max_length: ::std::os::raw::c_ulong,
    pub ptr: *mut ::std::os::raw::c_char,
    pub const_item: bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_UDF_INIT() {
    assert_eq!(
        ::std::mem::size_of::<UDF_INIT>(),
        40usize,
        concat!("Size of: ", stringify!(UDF_INIT))
    );
    assert_eq!(
        ::std::mem::align_of::<UDF_INIT>(),
        8usize,
        concat!("Alignment of ", stringify!(UDF_INIT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_INIT>())).maybe_null as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(UDF_INIT), "::", stringify!(maybe_null))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_INIT>())).decimals as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(UDF_INIT), "::", stringify!(decimals))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_INIT>())).max_length as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(UDF_INIT), "::", stringify!(max_length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_INIT>())).ptr as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(UDF_INIT), "::", stringify!(ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_INIT>())).const_item as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(UDF_INIT), "::", stringify!(const_item))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDF_INIT>())).extension as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(UDF_INIT), "::", stringify!(extension))
    );
}
pub const Item_udftype_UDFTYPE_FUNCTION: Item_udftype = 1;
pub const Item_udftype_UDFTYPE_AGGREGATE: Item_udftype = 2;
pub type Item_udftype = u32;
pub type Udf_func_clear = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut UDF_INIT, arg2: *mut ::std::os::raw::c_uchar, arg3: *mut ::std::os::raw::c_uchar),
>;
pub type Udf_func_add = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut UDF_INIT,
        arg2: *mut UDF_ARGS,
        arg3: *mut ::std::os::raw::c_uchar,
        arg4: *mut ::std::os::raw::c_uchar,
    ),
>;
pub type Udf_func_deinit = ::std::option::Option<unsafe extern "C" fn(arg1: *mut UDF_INIT)>;
pub type Udf_func_init = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut UDF_INIT, arg2: *mut UDF_ARGS, arg3: *mut ::std::os::raw::c_char) -> bool,
>;
pub type Udf_func_any = ::std::option::Option<unsafe extern "C" fn()>;
pub type Udf_func_double = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut UDF_INIT,
        arg2: *mut UDF_ARGS,
        arg3: *mut ::std::os::raw::c_uchar,
        arg4: *mut ::std::os::raw::c_uchar,
    ) -> f64,
>;
pub type Udf_func_longlong = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut UDF_INIT,
        arg2: *mut UDF_ARGS,
        arg3: *mut ::std::os::raw::c_uchar,
        arg4: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_longlong,
>;
pub type Udf_func_string = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut UDF_INIT,
        arg2: *mut UDF_ARGS,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_ulong,
        arg5: *mut ::std::os::raw::c_uchar,
        arg6: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    #[doc = " @}"]
    pub fn randominit(arg1: *mut rand_struct, seed1: ::std::os::raw::c_ulong, seed2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn my_rnd(arg1: *mut rand_struct) -> f64;
}
extern "C" {
    pub fn create_random_string(
        to: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        rand_st: *mut rand_struct,
    );
}
extern "C" {
    pub fn hash_password(
        to: *mut ::std::os::raw::c_ulong,
        password: *const ::std::os::raw::c_char,
        password_len: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn make_scrambled_password_323(to: *mut ::std::os::raw::c_char, password: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scramble_323(
        to: *mut ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn check_scramble_323(
        reply: *const ::std::os::raw::c_uchar,
        message: *const ::std::os::raw::c_char,
        salt: *mut ::std::os::raw::c_ulong,
    ) -> bool;
}
extern "C" {
    pub fn get_salt_from_password_323(res: *mut ::std::os::raw::c_ulong, password: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn make_password_from_salt_323(to: *mut ::std::os::raw::c_char, salt: *const ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn make_scrambled_password(to: *mut ::std::os::raw::c_char, password: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scramble(
        to: *mut ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn check_scramble(
        reply: *const ::std::os::raw::c_uchar,
        message: *const ::std::os::raw::c_char,
        hash_stage2: *const ::std::os::raw::c_uchar,
    ) -> bool;
}
extern "C" {
    pub fn get_salt_from_password(res: *mut ::std::os::raw::c_uchar, password: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn make_password_from_salt(to: *mut ::std::os::raw::c_char, hash_stage2: *const ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn octet2hex(
        to: *mut ::std::os::raw::c_char,
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn generate_sha256_scramble(
        dst: *mut ::std::os::raw::c_uchar,
        dst_size: size_t,
        src: *const ::std::os::raw::c_char,
        src_size: size_t,
        rnd: *const ::std::os::raw::c_char,
        rnd_size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn get_tty_password(opt_message: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_errno_to_sqlstate(mysql_errno: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn my_thread_init() -> bool;
}
extern "C" {
    pub fn my_thread_end();
}
extern "C" {
    pub fn net_field_length(packet: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn net_field_length_checked(
        packet: *mut *mut ::std::os::raw::c_uchar,
        max_length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn net_field_length_ll(packet: *mut *mut ::std::os::raw::c_uchar) -> u64;
}
extern "C" {
    pub fn net_store_length(
        pkg: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn net_length_size(num: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn net_field_length_size(pos: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_uint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(div_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(div_t), "::", stringify!(rem))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ldiv_t), "::", stringify!(rem))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(quot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(lldiv_t), "::", stringify!(rem))
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char, __endptr: *mut *mut ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(fptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(rptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(rand_deg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(rand_sep))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(random_data), "::", stringify!(end_ptr))
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char, __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__old_x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(drand48_data), "::", stringify!(__a))
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort, __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: ::std::os::raw::c_ulong, __size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(__status: ::std::os::raw::c_int, __arg: *mut ::std::os::raw::c_void),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: size_t, __size: size_t, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong, __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_client_plugin {
    pub type_: ::std::os::raw::c_int,
    pub interface_version: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub version: [::std::os::raw::c_uint; 3usize],
    pub license: *const ::std::os::raw::c_char,
    pub mysql_api: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_char,
            arg2: size_t,
            arg3: ::std::os::raw::c_int,
            arg4: *mut __va_list_tag,
        ) -> ::std::os::raw::c_int,
    >,
    pub deinit: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub options: ::std::option::Option<
        unsafe extern "C" fn(
            option: *const ::std::os::raw::c_char,
            arg1: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_st_mysql_client_plugin() {
    assert_eq!(
        ::std::mem::size_of::<st_mysql_client_plugin>(),
        88usize,
        concat!("Size of: ", stringify!(st_mysql_client_plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<st_mysql_client_plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(st_mysql_client_plugin))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).interface_version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(interface_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).author as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(author)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).desc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).version as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).license as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(license)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).mysql_api as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(mysql_api)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).init as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).deinit as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_client_plugin>())).options as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_client_plugin),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_PLUGIN_VIO_INFO {
    pub protocol: MYSQL_PLUGIN_VIO_INFO__bindgen_ty_1,
    pub socket: ::std::os::raw::c_int,
}
pub const MYSQL_PLUGIN_VIO_INFO_MYSQL_VIO_INVALID: MYSQL_PLUGIN_VIO_INFO__bindgen_ty_1 = 0;
pub const MYSQL_PLUGIN_VIO_INFO_MYSQL_VIO_TCP: MYSQL_PLUGIN_VIO_INFO__bindgen_ty_1 = 1;
pub const MYSQL_PLUGIN_VIO_INFO_MYSQL_VIO_SOCKET: MYSQL_PLUGIN_VIO_INFO__bindgen_ty_1 = 2;
pub const MYSQL_PLUGIN_VIO_INFO_MYSQL_VIO_PIPE: MYSQL_PLUGIN_VIO_INFO__bindgen_ty_1 = 3;
pub const MYSQL_PLUGIN_VIO_INFO_MYSQL_VIO_MEMORY: MYSQL_PLUGIN_VIO_INFO__bindgen_ty_1 = 4;
pub type MYSQL_PLUGIN_VIO_INFO__bindgen_ty_1 = u32;
#[test]
fn bindgen_test_layout_MYSQL_PLUGIN_VIO_INFO() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_PLUGIN_VIO_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(MYSQL_PLUGIN_VIO_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_PLUGIN_VIO_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(MYSQL_PLUGIN_VIO_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_PLUGIN_VIO_INFO>())).protocol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_PLUGIN_VIO_INFO),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_PLUGIN_VIO_INFO>())).socket as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_PLUGIN_VIO_INFO),
            "::",
            stringify!(socket)
        )
    );
}
pub const net_async_status_NET_ASYNC_COMPLETE: net_async_status = 0;
pub const net_async_status_NET_ASYNC_NOT_READY: net_async_status = 1;
pub const net_async_status_NET_ASYNC_ERROR: net_async_status = 2;
pub const net_async_status_NET_ASYNC_COMPLETE_NO_MORE_RESULTS: net_async_status = 3;
pub type net_async_status = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_PLUGIN_VIO {
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(
            vio: *mut MYSQL_PLUGIN_VIO,
            buf: *mut *mut ::std::os::raw::c_uchar,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(
            vio: *mut MYSQL_PLUGIN_VIO,
            packet: *const ::std::os::raw::c_uchar,
            packet_len: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub info: ::std::option::Option<unsafe extern "C" fn(vio: *mut MYSQL_PLUGIN_VIO, info: *mut MYSQL_PLUGIN_VIO_INFO)>,
    pub read_packet_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            vio: *mut MYSQL_PLUGIN_VIO,
            buf: *mut *mut ::std::os::raw::c_uchar,
            result: *mut ::std::os::raw::c_int,
        ) -> net_async_status,
    >,
    pub write_packet_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            vio: *mut MYSQL_PLUGIN_VIO,
            pkt: *const ::std::os::raw::c_uchar,
            pkt_len: ::std::os::raw::c_int,
            result: *mut ::std::os::raw::c_int,
        ) -> net_async_status,
    >,
}
#[test]
fn bindgen_test_layout_MYSQL_PLUGIN_VIO() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_PLUGIN_VIO>(),
        40usize,
        concat!("Size of: ", stringify!(MYSQL_PLUGIN_VIO))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_PLUGIN_VIO>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_PLUGIN_VIO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_PLUGIN_VIO>())).read_packet as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_PLUGIN_VIO),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_PLUGIN_VIO>())).write_packet as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_PLUGIN_VIO),
            "::",
            stringify!(write_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_PLUGIN_VIO>())).info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_PLUGIN_VIO),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_PLUGIN_VIO>())).read_packet_nonblocking as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_PLUGIN_VIO),
            "::",
            stringify!(read_packet_nonblocking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_PLUGIN_VIO>())).write_packet_nonblocking as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_PLUGIN_VIO),
            "::",
            stringify!(write_packet_nonblocking)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auth_plugin_t {
    pub type_: ::std::os::raw::c_int,
    pub interface_version: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub version: [::std::os::raw::c_uint; 3usize],
    pub license: *const ::std::os::raw::c_char,
    pub mysql_api: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_char,
            arg2: size_t,
            arg3: ::std::os::raw::c_int,
            arg4: *mut __va_list_tag,
        ) -> ::std::os::raw::c_int,
    >,
    pub deinit: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub options: ::std::option::Option<
        unsafe extern "C" fn(
            option: *const ::std::os::raw::c_char,
            arg1: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub authenticate_user: ::std::option::Option<
        unsafe extern "C" fn(vio: *mut MYSQL_PLUGIN_VIO, mysql: *mut MYSQL) -> ::std::os::raw::c_int,
    >,
    pub authenticate_user_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            vio: *mut MYSQL_PLUGIN_VIO,
            mysql: *mut MYSQL,
            result: *mut ::std::os::raw::c_int,
        ) -> net_async_status,
    >,
}
#[test]
fn bindgen_test_layout_auth_plugin_t() {
    assert_eq!(
        ::std::mem::size_of::<auth_plugin_t>(),
        104usize,
        concat!("Size of: ", stringify!(auth_plugin_t))
    );
    assert_eq!(
        ::std::mem::align_of::<auth_plugin_t>(),
        8usize,
        concat!("Alignment of ", stringify!(auth_plugin_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).type_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(auth_plugin_t), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).interface_version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(auth_plugin_t),
            "::",
            stringify!(interface_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).name as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(auth_plugin_t), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).author as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(auth_plugin_t), "::", stringify!(author))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).desc as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(auth_plugin_t), "::", stringify!(desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).version as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(auth_plugin_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).license as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(auth_plugin_t),
            "::",
            stringify!(license)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).mysql_api as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(auth_plugin_t),
            "::",
            stringify!(mysql_api)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).init as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(auth_plugin_t), "::", stringify!(init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).deinit as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(auth_plugin_t), "::", stringify!(deinit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).options as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(auth_plugin_t),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).authenticate_user as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(auth_plugin_t),
            "::",
            stringify!(authenticate_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<auth_plugin_t>())).authenticate_user_nonblocking as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(auth_plugin_t),
            "::",
            stringify!(authenticate_user_nonblocking)
        )
    );
}
pub type st_mysql_client_plugin_AUTHENTICATION = auth_plugin_t;
extern "C" {
    pub fn mysql_load_plugin(
        mysql: *mut MYSQL,
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        argc: ::std::os::raw::c_int,
        ...
    ) -> *mut st_mysql_client_plugin;
}
extern "C" {
    pub fn mysql_load_plugin_v(
        mysql: *mut MYSQL,
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        argc: ::std::os::raw::c_int,
        args: *mut __va_list_tag,
    ) -> *mut st_mysql_client_plugin;
}
extern "C" {
    pub fn mysql_client_find_plugin(
        mysql: *mut MYSQL,
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> *mut st_mysql_client_plugin;
}
extern "C" {
    pub fn mysql_client_register_plugin(
        mysql: *mut MYSQL,
        plugin: *mut st_mysql_client_plugin,
    ) -> *mut st_mysql_client_plugin;
}
extern "C" {
    pub fn mysql_plugin_options(
        plugin: *mut st_mysql_client_plugin,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const enum_mysql_timestamp_type_MYSQL_TIMESTAMP_NONE: enum_mysql_timestamp_type = -2;
pub const enum_mysql_timestamp_type_MYSQL_TIMESTAMP_ERROR: enum_mysql_timestamp_type = -1;
#[doc = " Stores year, month and day components."]
pub const enum_mysql_timestamp_type_MYSQL_TIMESTAMP_DATE: enum_mysql_timestamp_type = 0;
#[doc = "Stores all date and time components."]
#[doc = "Value is in UTC for `TIMESTAMP` type."]
#[doc = "Value is in local time zone for `DATETIME` type."]
pub const enum_mysql_timestamp_type_MYSQL_TIMESTAMP_DATETIME: enum_mysql_timestamp_type = 1;
#[doc = " Stores hour, minute, second and microsecond."]
pub const enum_mysql_timestamp_type_MYSQL_TIMESTAMP_TIME: enum_mysql_timestamp_type = 2;
#[doc = "A temporary type for `DATETIME` or `TIMESTAMP` types equipped with time"]
#[doc = "zone information. After the time zone information is reconciled, the type is"]
#[doc = "converted to MYSQL_TIMESTAMP_DATETIME."]
pub const enum_mysql_timestamp_type_MYSQL_TIMESTAMP_DATETIME_TZ: enum_mysql_timestamp_type = 3;
#[doc = "@file include/mysql_time.h"]
#[doc = "Time declarations shared between the server and client API:"]
#[doc = "you should not add anything to this header unless it's used"]
#[doc = "(and hence should be visible) in mysql.h."]
#[doc = "If you're looking for a place to add new time-related declaration,"]
#[doc = "it's most likely my_time.h. See also \"C API Handling of Date"]
#[doc = "and Time Values\" chapter in documentation."]
pub type enum_mysql_timestamp_type = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_TIME {
    pub year: ::std::os::raw::c_uint,
    pub month: ::std::os::raw::c_uint,
    pub day: ::std::os::raw::c_uint,
    pub hour: ::std::os::raw::c_uint,
    pub minute: ::std::os::raw::c_uint,
    pub second: ::std::os::raw::c_uint,
    #[doc = "< microseconds"]
    pub second_part: ::std::os::raw::c_ulong,
    pub neg: bool,
    pub time_type: enum_mysql_timestamp_type,
    #[doc = " The time zone displacement, specified in seconds."]
    pub time_zone_displacement: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MYSQL_TIME() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_TIME>(),
        48usize,
        concat!("Size of: ", stringify!(MYSQL_TIME))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_TIME>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_TIME))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).year as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MYSQL_TIME), "::", stringify!(year))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).month as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(MYSQL_TIME), "::", stringify!(month))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).day as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MYSQL_TIME), "::", stringify!(day))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).hour as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(MYSQL_TIME), "::", stringify!(hour))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).minute as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(MYSQL_TIME), "::", stringify!(minute))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).second as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(MYSQL_TIME), "::", stringify!(second))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).second_part as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_TIME),
            "::",
            stringify!(second_part)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).neg as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(MYSQL_TIME), "::", stringify!(neg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).time_type as *const _ as usize },
        36usize,
        concat!("Offset of field: ", stringify!(MYSQL_TIME), "::", stringify!(time_type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_TIME>())).time_zone_displacement as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_TIME),
            "::",
            stringify!(time_zone_displacement)
        )
    );
}
extern "C" {
    #[doc = "@file include/errmsg.h"]
    #[doc = ""]
    #[doc = "Error messages for MySQL clients."]
    #[doc = "These are constant and use the CR_ prefix."]
    #[doc = "<mysqlclient_ername.h> will contain auto-generated mappings"]
    #[doc = "containing the symbolic name and the number from this file,"]
    #[doc = "and the english error messages in libmysql/errmsg.c."]
    #[doc = ""]
    #[doc = "Dynamic error messages for the daemon are in share/language/errmsg.sys."]
    #[doc = "The server equivalent to <errmsg.h> is <mysqld_error.h>."]
    #[doc = "The server equivalent to <mysqlclient_ername.h> is <mysqld_ername.h>."]
    #[doc = ""]
    #[doc = "Note that the auth subsystem also uses codes with a CR_ prefix."]
    pub fn init_client_errs();
}
extern "C" {
    pub fn finish_client_errs();
}
extern "C" {
    pub static mut client_errors: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut mysql_port: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut mysql_unix_port: *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_FIELD {
    pub name: *mut ::std::os::raw::c_char,
    pub org_name: *mut ::std::os::raw::c_char,
    pub table: *mut ::std::os::raw::c_char,
    pub org_table: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub catalog: *mut ::std::os::raw::c_char,
    pub def: *mut ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_ulong,
    pub max_length: ::std::os::raw::c_ulong,
    pub name_length: ::std::os::raw::c_uint,
    pub org_name_length: ::std::os::raw::c_uint,
    pub table_length: ::std::os::raw::c_uint,
    pub org_table_length: ::std::os::raw::c_uint,
    pub db_length: ::std::os::raw::c_uint,
    pub catalog_length: ::std::os::raw::c_uint,
    pub def_length: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub decimals: ::std::os::raw::c_uint,
    pub charsetnr: ::std::os::raw::c_uint,
    pub type_: enum_field_types,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MYSQL_FIELD() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_FIELD>(),
        128usize,
        concat!("Size of: ", stringify!(MYSQL_FIELD))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_FIELD>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_FIELD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).name as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).org_name as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(org_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).table as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).org_table as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(org_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).db as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(db))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).catalog as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(catalog))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).def as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(def))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).length as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).max_length as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(max_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).name_length as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(name_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).org_name_length as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(org_name_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).table_length as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(table_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).org_table_length as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(org_table_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).db_length as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(db_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).catalog_length as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(catalog_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).def_length as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(def_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).flags as *const _ as usize },
        100usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).decimals as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(decimals))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).charsetnr as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(charsetnr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).type_ as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(MYSQL_FIELD), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_FIELD>())).extension as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_FIELD),
            "::",
            stringify!(extension)
        )
    );
}
pub type MYSQL_ROW = *mut *mut ::std::os::raw::c_char;
pub type MYSQL_FIELD_OFFSET = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_ROWS {
    pub next: *mut MYSQL_ROWS,
    pub data: MYSQL_ROW,
    pub length: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_MYSQL_ROWS() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_ROWS>(),
        24usize,
        concat!("Size of: ", stringify!(MYSQL_ROWS))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_ROWS>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_ROWS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_ROWS>())).next as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MYSQL_ROWS), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_ROWS>())).data as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MYSQL_ROWS), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_ROWS>())).length as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(MYSQL_ROWS), "::", stringify!(length))
    );
}
pub type MYSQL_ROW_OFFSET = *mut MYSQL_ROWS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEM_ROOT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_DATA {
    pub data: *mut MYSQL_ROWS,
    pub alloc: *mut MEM_ROOT,
    pub rows: u64,
    pub fields: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_MYSQL_DATA() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_DATA>(),
        32usize,
        concat!("Size of: ", stringify!(MYSQL_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_DATA>())).data as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MYSQL_DATA), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_DATA>())).alloc as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MYSQL_DATA), "::", stringify!(alloc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_DATA>())).rows as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(MYSQL_DATA), "::", stringify!(rows))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_DATA>())).fields as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(MYSQL_DATA), "::", stringify!(fields))
    );
}
pub const mysql_option_MYSQL_OPT_CONNECT_TIMEOUT: mysql_option = 0;
pub const mysql_option_MYSQL_OPT_COMPRESS: mysql_option = 1;
pub const mysql_option_MYSQL_OPT_NAMED_PIPE: mysql_option = 2;
pub const mysql_option_MYSQL_INIT_COMMAND: mysql_option = 3;
pub const mysql_option_MYSQL_READ_DEFAULT_FILE: mysql_option = 4;
pub const mysql_option_MYSQL_READ_DEFAULT_GROUP: mysql_option = 5;
pub const mysql_option_MYSQL_SET_CHARSET_DIR: mysql_option = 6;
pub const mysql_option_MYSQL_SET_CHARSET_NAME: mysql_option = 7;
pub const mysql_option_MYSQL_OPT_LOCAL_INFILE: mysql_option = 8;
pub const mysql_option_MYSQL_OPT_PROTOCOL: mysql_option = 9;
pub const mysql_option_MYSQL_SHARED_MEMORY_BASE_NAME: mysql_option = 10;
pub const mysql_option_MYSQL_OPT_READ_TIMEOUT: mysql_option = 11;
pub const mysql_option_MYSQL_OPT_WRITE_TIMEOUT: mysql_option = 12;
pub const mysql_option_MYSQL_OPT_USE_RESULT: mysql_option = 13;
pub const mysql_option_MYSQL_REPORT_DATA_TRUNCATION: mysql_option = 14;
pub const mysql_option_MYSQL_OPT_RECONNECT: mysql_option = 15;
pub const mysql_option_MYSQL_PLUGIN_DIR: mysql_option = 16;
pub const mysql_option_MYSQL_DEFAULT_AUTH: mysql_option = 17;
pub const mysql_option_MYSQL_OPT_BIND: mysql_option = 18;
pub const mysql_option_MYSQL_OPT_SSL_KEY: mysql_option = 19;
pub const mysql_option_MYSQL_OPT_SSL_CERT: mysql_option = 20;
pub const mysql_option_MYSQL_OPT_SSL_CA: mysql_option = 21;
pub const mysql_option_MYSQL_OPT_SSL_CAPATH: mysql_option = 22;
pub const mysql_option_MYSQL_OPT_SSL_CIPHER: mysql_option = 23;
pub const mysql_option_MYSQL_OPT_SSL_CRL: mysql_option = 24;
pub const mysql_option_MYSQL_OPT_SSL_CRLPATH: mysql_option = 25;
pub const mysql_option_MYSQL_OPT_CONNECT_ATTR_RESET: mysql_option = 26;
pub const mysql_option_MYSQL_OPT_CONNECT_ATTR_ADD: mysql_option = 27;
pub const mysql_option_MYSQL_OPT_CONNECT_ATTR_DELETE: mysql_option = 28;
pub const mysql_option_MYSQL_SERVER_PUBLIC_KEY: mysql_option = 29;
pub const mysql_option_MYSQL_ENABLE_CLEARTEXT_PLUGIN: mysql_option = 30;
pub const mysql_option_MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS: mysql_option = 31;
pub const mysql_option_MYSQL_OPT_MAX_ALLOWED_PACKET: mysql_option = 32;
pub const mysql_option_MYSQL_OPT_NET_BUFFER_LENGTH: mysql_option = 33;
pub const mysql_option_MYSQL_OPT_TLS_VERSION: mysql_option = 34;
pub const mysql_option_MYSQL_OPT_SSL_MODE: mysql_option = 35;
pub const mysql_option_MYSQL_OPT_GET_SERVER_PUBLIC_KEY: mysql_option = 36;
pub const mysql_option_MYSQL_OPT_RETRY_COUNT: mysql_option = 37;
pub const mysql_option_MYSQL_OPT_OPTIONAL_RESULTSET_METADATA: mysql_option = 38;
pub const mysql_option_MYSQL_OPT_SSL_FIPS_MODE: mysql_option = 39;
pub const mysql_option_MYSQL_OPT_TLS_CIPHERSUITES: mysql_option = 40;
pub const mysql_option_MYSQL_OPT_COMPRESSION_ALGORITHMS: mysql_option = 41;
pub const mysql_option_MYSQL_OPT_ZSTD_COMPRESSION_LEVEL: mysql_option = 42;
pub const mysql_option_MYSQL_OPT_LOAD_DATA_LOCAL_DIR: mysql_option = 43;
pub type mysql_option = u32;
#[doc = "@todo remove the \"extension\", move st_mysql_options completely"]
#[doc = "out of mysql.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_options_extention {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_options {
    pub connect_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub port: ::std::os::raw::c_uint,
    pub protocol: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub password: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub init_commands: *mut Init_commands_array,
    pub my_cnf_file: *mut ::std::os::raw::c_char,
    pub my_cnf_group: *mut ::std::os::raw::c_char,
    pub charset_dir: *mut ::std::os::raw::c_char,
    pub charset_name: *mut ::std::os::raw::c_char,
    pub ssl_key: *mut ::std::os::raw::c_char,
    pub ssl_cert: *mut ::std::os::raw::c_char,
    pub ssl_ca: *mut ::std::os::raw::c_char,
    pub ssl_capath: *mut ::std::os::raw::c_char,
    pub ssl_cipher: *mut ::std::os::raw::c_char,
    pub shared_memory_base_name: *mut ::std::os::raw::c_char,
    pub max_allowed_packet: ::std::os::raw::c_ulong,
    pub compress: bool,
    pub named_pipe: bool,
    #[doc = "The local address to bind when connecting to remote server."]
    pub bind_address: *mut ::std::os::raw::c_char,
    pub report_data_truncation: bool,
    pub local_infile_init: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub local_infile_read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub local_infile_end: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub local_infile_error: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub local_infile_userdata: *mut ::std::os::raw::c_void,
    pub extension: *mut st_mysql_options_extention,
}
#[test]
fn bindgen_test_layout_st_mysql_options() {
    assert_eq!(
        ::std::mem::size_of::<st_mysql_options>(),
        240usize,
        concat!("Size of: ", stringify!(st_mysql_options))
    );
    assert_eq!(
        ::std::mem::align_of::<st_mysql_options>(),
        8usize,
        concat!("Alignment of ", stringify!(st_mysql_options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).connect_timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(connect_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).read_timeout as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(read_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).write_timeout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(write_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).protocol as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).client_flag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(client_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).host as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).user as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).password as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).unix_socket as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(unix_socket)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).db as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(st_mysql_options), "::", stringify!(db))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).init_commands as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(init_commands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).my_cnf_file as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(my_cnf_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).my_cnf_group as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(my_cnf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).charset_dir as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(charset_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).charset_name as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(charset_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).ssl_key as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(ssl_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).ssl_cert as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(ssl_cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).ssl_ca as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(ssl_ca)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).ssl_capath as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(ssl_capath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).ssl_cipher as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(ssl_cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).shared_memory_base_name as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(shared_memory_base_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).max_allowed_packet as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(max_allowed_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).compress as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(compress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).named_pipe as *const _ as usize },
        169usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(named_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).bind_address as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(bind_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).report_data_truncation as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(report_data_truncation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).local_infile_init as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(local_infile_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).local_infile_read as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(local_infile_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).local_infile_end as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(local_infile_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).local_infile_error as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(local_infile_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).local_infile_userdata as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(local_infile_userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<st_mysql_options>())).extension as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(st_mysql_options),
            "::",
            stringify!(extension)
        )
    );
}
pub const mysql_status_MYSQL_STATUS_READY: mysql_status = 0;
pub const mysql_status_MYSQL_STATUS_GET_RESULT: mysql_status = 1;
pub const mysql_status_MYSQL_STATUS_USE_RESULT: mysql_status = 2;
pub const mysql_status_MYSQL_STATUS_STATEMENT_GET_RESULT: mysql_status = 3;
pub type mysql_status = u32;
pub const mysql_protocol_type_MYSQL_PROTOCOL_DEFAULT: mysql_protocol_type = 0;
pub const mysql_protocol_type_MYSQL_PROTOCOL_TCP: mysql_protocol_type = 1;
pub const mysql_protocol_type_MYSQL_PROTOCOL_SOCKET: mysql_protocol_type = 2;
pub const mysql_protocol_type_MYSQL_PROTOCOL_PIPE: mysql_protocol_type = 3;
pub const mysql_protocol_type_MYSQL_PROTOCOL_MEMORY: mysql_protocol_type = 4;
pub type mysql_protocol_type = u32;
pub const mysql_ssl_mode_SSL_MODE_DISABLED: mysql_ssl_mode = 1;
pub const mysql_ssl_mode_SSL_MODE_PREFERRED: mysql_ssl_mode = 2;
pub const mysql_ssl_mode_SSL_MODE_REQUIRED: mysql_ssl_mode = 3;
pub const mysql_ssl_mode_SSL_MODE_VERIFY_CA: mysql_ssl_mode = 4;
pub const mysql_ssl_mode_SSL_MODE_VERIFY_IDENTITY: mysql_ssl_mode = 5;
pub type mysql_ssl_mode = u32;
pub const mysql_ssl_fips_mode_SSL_FIPS_MODE_OFF: mysql_ssl_fips_mode = 0;
pub const mysql_ssl_fips_mode_SSL_FIPS_MODE_ON: mysql_ssl_fips_mode = 1;
pub const mysql_ssl_fips_mode_SSL_FIPS_MODE_STRICT: mysql_ssl_fips_mode = 2;
pub type mysql_ssl_fips_mode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct character_set {
    pub number: ::std::os::raw::c_uint,
    pub state: ::std::os::raw::c_uint,
    pub csname: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub comment: *const ::std::os::raw::c_char,
    pub dir: *const ::std::os::raw::c_char,
    pub mbminlen: ::std::os::raw::c_uint,
    pub mbmaxlen: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_character_set() {
    assert_eq!(
        ::std::mem::size_of::<character_set>(),
        48usize,
        concat!("Size of: ", stringify!(character_set))
    );
    assert_eq!(
        ::std::mem::align_of::<character_set>(),
        8usize,
        concat!("Alignment of ", stringify!(character_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<character_set>())).number as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(character_set), "::", stringify!(number))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<character_set>())).state as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(character_set), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<character_set>())).csname as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(character_set), "::", stringify!(csname))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<character_set>())).name as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(character_set), "::", stringify!(name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<character_set>())).comment as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(character_set),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<character_set>())).dir as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(character_set), "::", stringify!(dir))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<character_set>())).mbminlen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(character_set),
            "::",
            stringify!(mbminlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<character_set>())).mbmaxlen as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(character_set),
            "::",
            stringify!(mbmaxlen)
        )
    );
}
pub type MY_CHARSET_INFO = character_set;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_METHODS {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MYSQL {
    pub net: NET,
    pub connector_fd: *mut ::std::os::raw::c_uchar,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub passwd: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub server_version: *mut ::std::os::raw::c_char,
    pub host_info: *mut ::std::os::raw::c_char,
    pub info: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub charset: *mut CHARSET_INFO,
    pub fields: *mut MYSQL_FIELD,
    pub field_alloc: *mut MEM_ROOT,
    pub affected_rows: u64,
    pub insert_id: u64,
    pub extra_info: u64,
    pub thread_id: ::std::os::raw::c_ulong,
    pub packet_length: ::std::os::raw::c_ulong,
    pub port: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub server_capabilities: ::std::os::raw::c_ulong,
    pub protocol_version: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub server_status: ::std::os::raw::c_uint,
    pub server_language: ::std::os::raw::c_uint,
    pub warning_count: ::std::os::raw::c_uint,
    pub options: st_mysql_options,
    pub status: mysql_status,
    pub resultset_metadata: enum_resultset_metadata,
    pub free_me: bool,
    pub reconnect: bool,
    pub scramble: [::std::os::raw::c_char; 21usize],
    pub stmts: *mut LIST,
    pub methods: *const MYSQL_METHODS,
    pub thd: *mut ::std::os::raw::c_void,
    pub unbuffered_fetch_owner: *mut bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MYSQL() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL>(),
        1160usize,
        concat!("Size of: ", stringify!(MYSQL))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).net as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(net))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).connector_fd as *const _ as usize },
        664usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(connector_fd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).host as *const _ as usize },
        672usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(host))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).user as *const _ as usize },
        680usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(user))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).passwd as *const _ as usize },
        688usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(passwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).unix_socket as *const _ as usize },
        696usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(unix_socket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).server_version as *const _ as usize },
        704usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(server_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).host_info as *const _ as usize },
        712usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(host_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).info as *const _ as usize },
        720usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).db as *const _ as usize },
        728usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(db))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).charset as *const _ as usize },
        736usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(charset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).fields as *const _ as usize },
        744usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(fields))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).field_alloc as *const _ as usize },
        752usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(field_alloc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).affected_rows as *const _ as usize },
        760usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(affected_rows))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).insert_id as *const _ as usize },
        768usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(insert_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).extra_info as *const _ as usize },
        776usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(extra_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).thread_id as *const _ as usize },
        784usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(thread_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).packet_length as *const _ as usize },
        792usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(packet_length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).port as *const _ as usize },
        800usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).client_flag as *const _ as usize },
        808usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(client_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).server_capabilities as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL),
            "::",
            stringify!(server_capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).protocol_version as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL),
            "::",
            stringify!(protocol_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).field_count as *const _ as usize },
        828usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(field_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).server_status as *const _ as usize },
        832usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(server_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).server_language as *const _ as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL),
            "::",
            stringify!(server_language)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).warning_count as *const _ as usize },
        840usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(warning_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).options as *const _ as usize },
        848usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).status as *const _ as usize },
        1088usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).resultset_metadata as *const _ as usize },
        1092usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL),
            "::",
            stringify!(resultset_metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).free_me as *const _ as usize },
        1096usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(free_me))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).reconnect as *const _ as usize },
        1097usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(reconnect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).scramble as *const _ as usize },
        1098usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(scramble))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).stmts as *const _ as usize },
        1120usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(stmts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).methods as *const _ as usize },
        1128usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(methods))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).thd as *const _ as usize },
        1136usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(thd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).unbuffered_fetch_owner as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL),
            "::",
            stringify!(unbuffered_fetch_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL>())).extension as *const _ as usize },
        1152usize,
        concat!("Offset of field: ", stringify!(MYSQL), "::", stringify!(extension))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_RES {
    pub row_count: u64,
    pub fields: *mut MYSQL_FIELD,
    pub data: *mut MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub lengths: *mut ::std::os::raw::c_ulong,
    pub handle: *mut MYSQL,
    pub methods: *const MYSQL_METHODS,
    pub row: MYSQL_ROW,
    pub current_row: MYSQL_ROW,
    pub field_alloc: *mut MEM_ROOT,
    pub field_count: ::std::os::raw::c_uint,
    pub current_field: ::std::os::raw::c_uint,
    pub eof: bool,
    pub unbuffered_fetch_cancelled: bool,
    pub metadata: enum_resultset_metadata,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MYSQL_RES() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_RES>(),
        104usize,
        concat!("Size of: ", stringify!(MYSQL_RES))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_RES>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_RES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).row_count as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(row_count))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).fields as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(fields))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).data as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).data_cursor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RES),
            "::",
            stringify!(data_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).lengths as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(lengths))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).handle as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).methods as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(methods))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).row as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(row))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).current_row as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RES),
            "::",
            stringify!(current_row)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).field_alloc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RES),
            "::",
            stringify!(field_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).field_count as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RES),
            "::",
            stringify!(field_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).current_field as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RES),
            "::",
            stringify!(current_field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).eof as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(eof))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).unbuffered_fetch_cancelled as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RES),
            "::",
            stringify!(unbuffered_fetch_cancelled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).metadata as *const _ as usize },
        92usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(metadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RES>())).extension as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(MYSQL_RES), "::", stringify!(extension))
    );
}
#[doc = "Struct for information about a replication stream."]
#[doc = ""]
#[doc = "@sa mysql_binlog_open()"]
#[doc = "@sa mysql_binlog_fetch()"]
#[doc = "@sa mysql_binlog_close()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_RPL {
    pub file_name_length: size_t,
    #[doc = " Length of the 'file_name' or 0"]
    pub file_name: *const ::std::os::raw::c_char,
    #[doc = " Filename of the binary log to read"]
    pub start_position: u64,
    #[doc = " Position in the binary log to"]
    pub server_id: ::std::os::raw::c_uint,
    #[doc = " Server ID to use when identifying"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = " Size of gtid set data"]
    pub gtid_set_encoded_size: size_t,
    pub fix_gtid_set:
        ::std::option::Option<unsafe extern "C" fn(rpl: *mut MYSQL_RPL, packet_gtid_set: *mut ::std::os::raw::c_uchar)>,
    pub gtid_set_arg: *mut ::std::os::raw::c_void,
    #[doc = " GTID set data or an argument for"]
    pub size: ::std::os::raw::c_ulong,
    #[doc = " Size of the packet returned by"]
    pub buffer: *const ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_MYSQL_RPL() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_RPL>(),
        72usize,
        concat!("Size of: ", stringify!(MYSQL_RPL))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_RPL>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_RPL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).file_name_length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RPL),
            "::",
            stringify!(file_name_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).file_name as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MYSQL_RPL), "::", stringify!(file_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).start_position as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RPL),
            "::",
            stringify!(start_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).server_id as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(MYSQL_RPL), "::", stringify!(server_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).flags as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(MYSQL_RPL), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).gtid_set_encoded_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RPL),
            "::",
            stringify!(gtid_set_encoded_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).fix_gtid_set as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RPL),
            "::",
            stringify!(fix_gtid_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).gtid_set_arg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_RPL),
            "::",
            stringify!(gtid_set_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).size as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(MYSQL_RPL), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_RPL>())).buffer as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(MYSQL_RPL), "::", stringify!(buffer))
    );
}
extern "C" {
    pub fn mysql_server_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        groups: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_server_end();
}
extern "C" {
    pub fn mysql_thread_init() -> bool;
}
extern "C" {
    pub fn mysql_thread_end();
}
extern "C" {
    pub fn mysql_num_rows(res: *mut MYSQL_RES) -> u64;
}
extern "C" {
    pub fn mysql_num_fields(res: *mut MYSQL_RES) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_eof(res: *mut MYSQL_RES) -> bool;
}
extern "C" {
    pub fn mysql_fetch_field_direct(res: *mut MYSQL_RES, fieldnr: ::std::os::raw::c_uint) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_fetch_fields(res: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_row_tell(res: *mut MYSQL_RES) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_field_tell(res: *mut MYSQL_RES) -> MYSQL_FIELD_OFFSET;
}
extern "C" {
    pub fn mysql_result_metadata(result: *mut MYSQL_RES) -> enum_resultset_metadata;
}
extern "C" {
    pub fn mysql_field_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_affected_rows(mysql: *mut MYSQL) -> u64;
}
extern "C" {
    pub fn mysql_insert_id(mysql: *mut MYSQL) -> u64;
}
extern "C" {
    pub fn mysql_errno(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_error(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_sqlstate(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_warning_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_thread_id(mysql: *mut MYSQL) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_character_set_name(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_set_character_set(mysql: *mut MYSQL, csname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_init(mysql: *mut MYSQL) -> *mut MYSQL;
}
extern "C" {
    pub fn mysql_ssl_set(
        mysql: *mut MYSQL,
        key: *const ::std::os::raw::c_char,
        cert: *const ::std::os::raw::c_char,
        ca: *const ::std::os::raw::c_char,
        capath: *const ::std::os::raw::c_char,
        cipher: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn mysql_get_ssl_cipher(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_change_user(
        mysql: *mut MYSQL,
        user: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        db: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn mysql_real_connect(
        mysql: *mut MYSQL,
        host: *const ::std::os::raw::c_char,
        user: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        db: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_uint,
        unix_socket: *const ::std::os::raw::c_char,
        clientflag: ::std::os::raw::c_ulong,
    ) -> *mut MYSQL;
}
extern "C" {
    pub fn mysql_select_db(mysql: *mut MYSQL, db: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_query(mysql: *mut MYSQL, q: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_send_query(
        mysql: *mut MYSQL,
        q: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_real_query(
        mysql: *mut MYSQL,
        q: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_store_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_use_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_real_connect_nonblocking(
        mysql: *mut MYSQL,
        host: *const ::std::os::raw::c_char,
        user: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        db: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_uint,
        unix_socket: *const ::std::os::raw::c_char,
        clientflag: ::std::os::raw::c_ulong,
    ) -> net_async_status;
}
extern "C" {
    pub fn mysql_send_query_nonblocking(
        mysql: *mut MYSQL,
        query: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> net_async_status;
}
extern "C" {
    pub fn mysql_real_query_nonblocking(
        mysql: *mut MYSQL,
        query: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> net_async_status;
}
extern "C" {
    pub fn mysql_store_result_nonblocking(mysql: *mut MYSQL, result: *mut *mut MYSQL_RES) -> net_async_status;
}
extern "C" {
    pub fn mysql_next_result_nonblocking(mysql: *mut MYSQL) -> net_async_status;
}
extern "C" {
    pub fn mysql_select_db_nonblocking(
        mysql: *mut MYSQL,
        db: *const ::std::os::raw::c_char,
        error: *mut bool,
    ) -> net_async_status;
}
extern "C" {
    pub fn mysql_get_character_set_info(mysql: *mut MYSQL, charset: *mut MY_CHARSET_INFO);
}
extern "C" {
    pub fn mysql_session_track_get_first(
        mysql: *mut MYSQL,
        type_: enum_session_state_type,
        data: *mut *const ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_session_track_get_next(
        mysql: *mut MYSQL,
        type_: enum_session_state_type,
        data: *mut *const ::std::os::raw::c_char,
        length: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_set_local_infile_handler(
        mysql: *mut MYSQL,
        local_infile_init: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        local_infile_read: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int,
        >,
        local_infile_end: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        local_infile_error: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int,
        >,
        arg1: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn mysql_set_local_infile_default(mysql: *mut MYSQL);
}
extern "C" {
    pub fn mysql_shutdown(mysql: *mut MYSQL, shutdown_level: mysql_enum_shutdown_level) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_dump_debug_info(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_refresh(mysql: *mut MYSQL, refresh_options: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_kill(mysql: *mut MYSQL, pid: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_set_server_option(mysql: *mut MYSQL, option: enum_mysql_set_option) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_ping(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stat(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_server_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_client_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_client_version() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_get_host_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_server_version(mysql: *mut MYSQL) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_get_proto_info(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_list_dbs(mysql: *mut MYSQL, wild: *const ::std::os::raw::c_char) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_list_tables(mysql: *mut MYSQL, wild: *const ::std::os::raw::c_char) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_list_processes(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_options(
        mysql: *mut MYSQL,
        option: mysql_option,
        arg: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_options4(
        mysql: *mut MYSQL,
        option: mysql_option,
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_get_option(
        mysql: *mut MYSQL,
        option: mysql_option,
        arg: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_free_result(result: *mut MYSQL_RES);
}
extern "C" {
    pub fn mysql_free_result_nonblocking(result: *mut MYSQL_RES) -> net_async_status;
}
extern "C" {
    pub fn mysql_data_seek(result: *mut MYSQL_RES, offset: u64);
}
extern "C" {
    pub fn mysql_row_seek(result: *mut MYSQL_RES, offset: MYSQL_ROW_OFFSET) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_field_seek(result: *mut MYSQL_RES, offset: MYSQL_FIELD_OFFSET) -> MYSQL_FIELD_OFFSET;
}
extern "C" {
    pub fn mysql_fetch_row(result: *mut MYSQL_RES) -> MYSQL_ROW;
}
extern "C" {
    pub fn mysql_fetch_row_nonblocking(res: *mut MYSQL_RES, row: *mut MYSQL_ROW) -> net_async_status;
}
extern "C" {
    pub fn mysql_fetch_lengths(result: *mut MYSQL_RES) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_fetch_field(result: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_list_fields(
        mysql: *mut MYSQL,
        table: *const ::std::os::raw::c_char,
        wild: *const ::std::os::raw::c_char,
    ) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_escape_string(
        to: *mut ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        from_length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_hex_string(
        to: *mut ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        from_length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_real_escape_string(
        mysql: *mut MYSQL,
        to: *mut ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_real_escape_string_quote(
        mysql: *mut MYSQL,
        to: *mut ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
        quote: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_debug(debug: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn myodbc_remove_escape(mysql: *mut MYSQL, name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn mysql_thread_safe() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_read_query_result(mysql: *mut MYSQL) -> bool;
}
extern "C" {
    pub fn mysql_reset_connection(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_binlog_open(mysql: *mut MYSQL, rpl: *mut MYSQL_RPL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_binlog_fetch(mysql: *mut MYSQL, rpl: *mut MYSQL_RPL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_binlog_close(mysql: *mut MYSQL, rpl: *mut MYSQL_RPL);
}
pub const enum_mysql_stmt_state_MYSQL_STMT_INIT_DONE: enum_mysql_stmt_state = 1;
pub const enum_mysql_stmt_state_MYSQL_STMT_PREPARE_DONE: enum_mysql_stmt_state = 2;
pub const enum_mysql_stmt_state_MYSQL_STMT_EXECUTE_DONE: enum_mysql_stmt_state = 3;
pub const enum_mysql_stmt_state_MYSQL_STMT_FETCH_DONE: enum_mysql_stmt_state = 4;
pub type enum_mysql_stmt_state = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_BIND {
    pub length: *mut ::std::os::raw::c_ulong,
    pub is_null: *mut bool,
    pub buffer: *mut ::std::os::raw::c_void,
    pub error: *mut bool,
    pub row_ptr: *mut ::std::os::raw::c_uchar,
    pub store_param_func: ::std::option::Option<unsafe extern "C" fn(net: *mut NET, param: *mut MYSQL_BIND)>,
    pub fetch_result: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut MYSQL_BIND, arg2: *mut MYSQL_FIELD, row: *mut *mut ::std::os::raw::c_uchar),
    >,
    pub skip_result: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut MYSQL_BIND, arg2: *mut MYSQL_FIELD, row: *mut *mut ::std::os::raw::c_uchar),
    >,
    pub buffer_length: ::std::os::raw::c_ulong,
    pub offset: ::std::os::raw::c_ulong,
    pub length_value: ::std::os::raw::c_ulong,
    pub param_number: ::std::os::raw::c_uint,
    pub pack_length: ::std::os::raw::c_uint,
    pub buffer_type: enum_field_types,
    pub error_value: bool,
    pub is_unsigned: bool,
    pub long_data_used: bool,
    pub is_null_value: bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MYSQL_BIND() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_BIND>(),
        112usize,
        concat!("Size of: ", stringify!(MYSQL_BIND))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_BIND>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_BIND))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).length as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MYSQL_BIND), "::", stringify!(length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).is_null as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MYSQL_BIND), "::", stringify!(is_null))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).buffer as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(MYSQL_BIND), "::", stringify!(buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).error as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(MYSQL_BIND), "::", stringify!(error))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).row_ptr as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(MYSQL_BIND), "::", stringify!(row_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).store_param_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(store_param_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).fetch_result as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(fetch_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).skip_result as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(skip_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).buffer_length as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(buffer_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).offset as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(MYSQL_BIND), "::", stringify!(offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).length_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(length_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).param_number as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(param_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).pack_length as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(pack_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).buffer_type as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(buffer_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).error_value as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(error_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).is_unsigned as *const _ as usize },
        101usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(is_unsigned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).long_data_used as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(long_data_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).is_null_value as *const _ as usize },
        103usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_BIND),
            "::",
            stringify!(is_null_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_BIND>())).extension as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(MYSQL_BIND), "::", stringify!(extension))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MYSQL_STMT_EXT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MYSQL_STMT {
    pub mem_root: *mut MEM_ROOT,
    pub list: LIST,
    pub mysql: *mut MYSQL,
    pub params: *mut MYSQL_BIND,
    pub bind: *mut MYSQL_BIND,
    pub fields: *mut MYSQL_FIELD,
    pub result: MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub read_row_func: ::std::option::Option<
        unsafe extern "C" fn(stmt: *mut MYSQL_STMT, row: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int,
    >,
    pub affected_rows: u64,
    pub insert_id: u64,
    pub stmt_id: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub prefetch_rows: ::std::os::raw::c_ulong,
    pub server_status: ::std::os::raw::c_uint,
    pub last_errno: ::std::os::raw::c_uint,
    pub param_count: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub state: enum_mysql_stmt_state,
    pub last_error: [::std::os::raw::c_char; 512usize],
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    pub send_types_to_server: bool,
    pub bind_param_done: bool,
    pub bind_result_done: ::std::os::raw::c_uchar,
    pub unbuffered_fetch_cancelled: bool,
    pub update_max_length: bool,
    pub extension: *mut MYSQL_STMT_EXT,
}
#[test]
fn bindgen_test_layout_MYSQL_STMT() {
    assert_eq!(
        ::std::mem::size_of::<MYSQL_STMT>(),
        704usize,
        concat!("Size of: ", stringify!(MYSQL_STMT))
    );
    assert_eq!(
        ::std::mem::align_of::<MYSQL_STMT>(),
        8usize,
        concat!("Alignment of ", stringify!(MYSQL_STMT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).mem_root as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(mem_root))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).list as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).mysql as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(mysql))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).params as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).bind as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(bind))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).fields as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(fields))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).result as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).data_cursor as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(data_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).read_row_func as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(read_row_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).affected_rows as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(affected_rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).insert_id as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(insert_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).stmt_id as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(stmt_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).flags as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).prefetch_rows as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(prefetch_rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).server_status as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(server_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).last_errno as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(last_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).param_count as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(param_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).field_count as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(field_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).state as *const _ as usize },
        168usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).last_error as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(last_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).sqlstate as *const _ as usize },
        684usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(sqlstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).send_types_to_server as *const _ as usize },
        690usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(send_types_to_server)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).bind_param_done as *const _ as usize },
        691usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(bind_param_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).bind_result_done as *const _ as usize },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(bind_result_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).unbuffered_fetch_cancelled as *const _ as usize },
        693usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(unbuffered_fetch_cancelled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).update_max_length as *const _ as usize },
        694usize,
        concat!(
            "Offset of field: ",
            stringify!(MYSQL_STMT),
            "::",
            stringify!(update_max_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MYSQL_STMT>())).extension as *const _ as usize },
        696usize,
        concat!("Offset of field: ", stringify!(MYSQL_STMT), "::", stringify!(extension))
    );
}
pub const enum_stmt_attr_type_STMT_ATTR_UPDATE_MAX_LENGTH: enum_stmt_attr_type = 0;
pub const enum_stmt_attr_type_STMT_ATTR_CURSOR_TYPE: enum_stmt_attr_type = 1;
pub const enum_stmt_attr_type_STMT_ATTR_PREFETCH_ROWS: enum_stmt_attr_type = 2;
pub type enum_stmt_attr_type = u32;
extern "C" {
    pub fn mysql_bind_param(
        mysql: *mut MYSQL,
        n_params: ::std::os::raw::c_uint,
        binds: *mut MYSQL_BIND,
        names: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn mysql_stmt_init(mysql: *mut MYSQL) -> *mut MYSQL_STMT;
}
extern "C" {
    pub fn mysql_stmt_prepare(
        stmt: *mut MYSQL_STMT,
        query: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_execute(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_fetch(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_fetch_column(
        stmt: *mut MYSQL_STMT,
        bind_arg: *mut MYSQL_BIND,
        column: ::std::os::raw::c_uint,
        offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_store_result(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_param_count(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_stmt_attr_set(
        stmt: *mut MYSQL_STMT,
        attr_type: enum_stmt_attr_type,
        attr: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn mysql_stmt_attr_get(
        stmt: *mut MYSQL_STMT,
        attr_type: enum_stmt_attr_type,
        attr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn mysql_stmt_bind_param(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND) -> bool;
}
extern "C" {
    pub fn mysql_stmt_bind_result(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND) -> bool;
}
extern "C" {
    pub fn mysql_stmt_close(stmt: *mut MYSQL_STMT) -> bool;
}
extern "C" {
    pub fn mysql_stmt_reset(stmt: *mut MYSQL_STMT) -> bool;
}
extern "C" {
    pub fn mysql_stmt_free_result(stmt: *mut MYSQL_STMT) -> bool;
}
extern "C" {
    pub fn mysql_stmt_send_long_data(
        stmt: *mut MYSQL_STMT,
        param_number: ::std::os::raw::c_uint,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> bool;
}
extern "C" {
    pub fn mysql_stmt_result_metadata(stmt: *mut MYSQL_STMT) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_stmt_param_metadata(stmt: *mut MYSQL_STMT) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_stmt_errno(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_stmt_error(stmt: *mut MYSQL_STMT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_stmt_sqlstate(stmt: *mut MYSQL_STMT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_stmt_row_seek(stmt: *mut MYSQL_STMT, offset: MYSQL_ROW_OFFSET) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_stmt_row_tell(stmt: *mut MYSQL_STMT) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_stmt_data_seek(stmt: *mut MYSQL_STMT, offset: u64);
}
extern "C" {
    pub fn mysql_stmt_num_rows(stmt: *mut MYSQL_STMT) -> u64;
}
extern "C" {
    pub fn mysql_stmt_affected_rows(stmt: *mut MYSQL_STMT) -> u64;
}
extern "C" {
    pub fn mysql_stmt_insert_id(stmt: *mut MYSQL_STMT) -> u64;
}
extern "C" {
    pub fn mysql_stmt_field_count(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_commit(mysql: *mut MYSQL) -> bool;
}
extern "C" {
    pub fn mysql_rollback(mysql: *mut MYSQL) -> bool;
}
extern "C" {
    pub fn mysql_autocommit(mysql: *mut MYSQL, auto_mode: bool) -> bool;
}
extern "C" {
    pub fn mysql_more_results(mysql: *mut MYSQL) -> bool;
}
extern "C" {
    pub fn mysql_next_result(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_next_result(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_close(sock: *mut MYSQL);
}
extern "C" {
    pub fn mysql_reset_server_public_key();
}
extern "C" {
    pub fn mysql_real_connect_dns_srv(
        mysql: *mut MYSQL,
        dns_srv_name: *const ::std::os::raw::c_char,
        user: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        db: *const ::std::os::raw::c_char,
        client_flag: ::std::os::raw::c_ulong,
    ) -> *mut MYSQL;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Init_commands_array {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CHARSET_INFO {
    pub _address: u8,
}
